[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下一个经典的面试题：new String("abc")到底创建了几个对象？。

> 理解String对象创建机制，避免内存浪费！

## 引言：一个经典的面试陷阱

"new String("abc")到底创建了几个对象？"这个问题看似简单，却难倒了无数Java开发者。今天，我们就来彻底揭开这个谜题，让你不仅掌握理论知识，更能应用到实际开发中。

## 一、字符串常量池：Java的内存优化艺术

在深入探讨之前，我们先来理解Java的**字符串常量池**机制。可以把字符串常量池想象成一个**图书馆的图书目录**，而每个字符串都是一本独特的图书。

当Java程序需要某个字符串时，会先检查"图书馆目录"中是否已经有这本书。如果有，直接告诉你书的位置；如果没有，则新购一本并登记到目录中。这种机制避免了相同内容的字符串重复创建，节省了大量内存空间。

## 二、new String("abc")的对象创建分析

现在让我们回到核心问题：`new String("abc")` 到底创建了几个对象？

### 情况一：常量池中不存在"abc"（创建2个对象）

当字符串常量池中不存在"abc"时，这行代码会创建**两个对象**：

1. **常量池对象**：字面量"abc"对应的字符串对象，存储在字符串常量池中
2. **堆内存对象**：通过new关键字在堆内存中创建的String对象

```java
// 首次执行，创建两个对象
String s = new String("abc");
```

这个过程可以用下面的流程图表示：

```
执行new String("abc")
↓
检查常量池中是否有"abc"
↓
否 → 在常量池创建"abc"对象
↓
在堆内存创建新的String对象
↓
返回堆内存对象的引用
```

### 情况二：常量池中已存在"abc"（创建1个对象）

如果常量池中已经存在"abc"字符串，那么只会在堆中创建一个新对象：

```java
// 先执行这个，常量池中已有"abc"
String s1 = "abc";

// 此时只创建1个对象（堆中的新对象）
String s2 = new String("abc");
```

## 三、字节码层面的实证分析

理论说了这么多，让我们从字节码层面看看实际证据：

```java
public class MainTest {
    public static void main(String[] args) {
        String s = new String("abc");
    }
}
```

通过`javap -verbose`反编译后，我们可以看到关键字节码指令：

```
0: new           #2                  // class java/lang/String
3: dup
4: ldc           #3                  // String abc
6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
9: astore_1
```

其中`ldc #3`将常量池中的"abc"加载到操作数栈，`new #2`在堆中创建新对象。这从底层证实了对象创建过程。

## 四、实战场景与性能影响

### 场景一：循环中的字符串创建

```java
// 不推荐的写法 - 可能造成内存浪费
for (int i = 0; i < 1000; i++) {
    String s = new String("constant"); // 每次循环都创建新对象
}

// 推荐的写法
for (int i = 0; i < 1000; i++) {
    String s = "constant"; // 重复使用常量池中的对象
}
```

### 场景二：数据库查询结果处理

假设从数据库查询用户名，如果用户名都是"admin"，使用new String()会导致内存浪费：

```java
// 不推荐的写法
List<String> usernames = dbQuery.getUsernames();
for (String name : usernames) {
    String processedName = new String(name); // 不必要的对象创建
}

// 推荐的写法
List<String> usernames = dbQuery.getUsernames();
for (String name : usernames) {
    String processedName = name; // 直接引用
}
```

## 五、不同JDK版本的差异

需要注意的是，字符串常量池的位置在不同JDK版本中有所变化：

- **JDK 1.6及之前**：常量池位于永久代（PermGen）
- **JDK 1.7及之后**：常量池移至主堆内存

这种变化影响了内存回收策略，但**不影响new String("abc")创建对象数量的逻辑**。

## 六、总结与最佳实践

回到最初的问题：`new String("abc")`到底创建了几个对象？答案是：**取决于字符串常量池的状态，可能是1个或2个对象**。

**最佳实践建议**：

1. **优先使用字面量赋值**：`String s = "abc"`而不是`new String("abc")`
2. **在需要显式创建新对象时才使用new String()**：如安全敏感场景
3. **注意字符串拼接操作**：使用StringBuilder或StringBuffer进行频繁拼接

理解String对象创建机制不仅有助于应对面试，更能帮助我们在实际开发中编写出更高效、更健壮的Java代码。希望本文能为你带来收获！

## 参考资料

1. https://www.qcloud.com/developer/article/2505724
2. https://blog.csdn.net/q68686/article/details/147294591
3. https://juejin.cn/post/6971741394251546661
4. https://blog.csdn.net/white_pure/article/details/145813292
5. https://juejin.cn/post/6878685749446148109
6. https://m.blog.csdn.net/kite30/article/details/47273159
7. https://docs.pingcode.com/baike/221954
8. https://blog.csdn.net/lijiawnen/article/details/82288649

* 本文主要观点基于以上参考资料，结合实际开发经验整理而成。转载请注明出处。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)


【转载须知】：**转载请注明原文出处及作者信息**