
> 在我们日常开发中，代理模式就像明星的经纪人，控制着外界对真实对象的访问。今天，让我们一起揭开代理模式的神秘面纱。

代理模式是一种常用的设计模式，它通过在客户端和目标对象之间引入一个中间层（即代理），来控制对目标对象的访问。

代理模式有助于降低客户端与目标对象之间的耦合度，提高代码的可扩展性和可维护性。

## 一、代理模式的基本概念

### 1.1 什么是代理模式？

简单来说，**代理模式就是用一个代理对象来替代原始对象**，从而控制对原始对象的访问。代理对象拥有与原始对象相同的接口，客户端与代理对象交互，而不直接访问原始对象。

这就像明星和经纪人的关系：你想邀请明星演出，不能直接联系明星本人，而是要通过经纪人洽谈。经纪人会在明星出场前谈好价格和条件，在演出结束后处理结算事宜。

### 1.2 代理模式的三种角色

- **抽象主题角色**：声明真实主题与代理的共同接口方法。
- **真实主题角色**：定义了代理所表示的真实对象，是负责执行系统真正逻辑的业务对象。
- **代理主题角色**：内部持有真实主题的引用，可以控制、扩展真实主题的功能。

## 二、静态代理：老实可靠的专属经纪人

### 2.1 静态代理的工作原理

静态代理是指代理类与目标类在编译时期就已经确定，代理类的实例化是在运行时期之前完成的。

**静态代理需要手动编写代理类**，并且代理类必须实现与目标类相同的接口。在代理类中，我们调用目标类的方法，并在其前后添加额外逻辑。

```java
// 接口
public interface MsgService {
    void sendMsg(String message);
}

// 目标类
public class MsgServiceImpl implements MsgService {
    @Override
    public void sendMsg(String message) {
        System.out.println("我要发送短信了");
    }
}

// 静态代理类
public class MsgProxy implements MsgService {
    private final MsgService msgService;
    
    public MsgProxy(MsgService msgService) {
        this.msgService = msgService;
    }
    
    @Override
    public void sendMsg(String message) {
        System.out.println("发短信之前");
        msgService.sendMsg(message);
        System.out.println("发短信之后");
    }
}
```

### 2.2 静态代理的优缺点

**优点**：实现简单，易于理解。

**缺点**：扩展性差，当目标类发生变化时，需要修改和重新编译代理类。如果接口增加方法，所有实现类和代理类都需要修改。

### 2.3 静态代理的实际应用场景

静态代理适用于对目标方法的额外处理逻辑相对固定的情况，例如日志记录、事务处理等。

一个典型应用是**数据源路由代理**，根据数据对象特征动态选择数据源：

```java
public class OrderServiceStaticProxy implements IOrderService {
    private IOrderService orderService;
    
    public int createOrder(Order order) {
        before();
        // 根据订单创建时间选择数据源
        Long time = order.getCreateTime();
        Integer dbRouter = Integer.valueOf(yearFormat.format(new Date(time)));
        DynamicDataSourceEntity.set(dbRouter);
        
        this.orderService.createOrder(order);
        DynamicDataSourceEntity.restore();
        
        after();
        return 0;
    }
}
```

这种代理在编译期就已经确定，像一份**长期雇佣合同**，专一而稳定，但缺乏灵活性。

## 三、动态代理：灵活多能的代理平台

### 3.1 动态代理的核心思想

动态代理是指代理类与目标类在运行时期动态生成，可以根据需要动态地创建代理类的实例。

**动态代理不需要手动编写代理类**，而是利用Java的反射机制在运行时动态生成代理类。这使得我们能够用一个代理处理器处理多种不同类型的对象。

### 3.2 JDK动态代理：基于接口的代理

JDK动态代理是Java原生提供的代理机制，主要依赖于`java.lang.reflect.Proxy`类和`InvocationHandler`接口。

```java
// 定义调用处理器
public class DynamicProxyInvokeHandler implements InvocationHandler {
    private final Object target;
    
    public DynamicProxyInvokeHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("调用方法之前：" + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("调用方法之后：" + method.getName());
        return result;
    }
}

// 使用动态代理
public class DynamicProxyFactory {
    public static Object getProxy(Object target) {
        return Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new DynamicProxyInvokeHandler(target)
        );
    }
}
```

**JDK动态代理的限制**：只能代理实现了接口的类。

### 3.3 CGLIB动态代理：基于继承的代理

CGLIB是一个强大的高性能代码生成库，它通过继承目标类并重写方法的方式实现代理，因此**不需要目标类实现接口**。

```java
// CGLIB方法拦截器
public class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("调用代理方法之前");
        Object result = methodProxy.invokeSuper(o, objects);
        System.out.println("调用代理方法之后");
        return result;
    }
}

// CGLIB代理工厂
public class CGLibProxyFactory {
    public static Object getProxy(Class<?> clazz) {
        Enhancer enhancer = new Enhancer();
        enhancer.setClassLoader(clazz.getClassLoader());
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(new MyMethodInterceptor());
        return enhancer.create();
    }
}
```

**CGLIB的限制**：不能代理final类和final方法。

## 四、静态代理 vs 动态代理：本质区别剖析

### 4.1 从JVM层面看区别

**静态代理**在编译时就将接口、实现类、代理类变成了一个个实际的class文件。

**动态代理**则是在运行时动态生成类字节码，并加载到JVM中的。

这就好比**纸质书与电子书的区别**：静态代理像纸质书，印刷后内容就固定了；动态代理像电子书，可以根据需要随时调整内容和格式。

### 4.2 灵活性对比

静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活。如果接口新增方法，目标对象和代理对象都要修改。

动态代理则非常灵活，不需要针对每个目标类都单独创建一个代理类。**所有方法调用都集中到一个调用处理器中**处理。

### 4.3 性能考量

静态代理在运行期性能略高，因为调用关系在编译期已经确定。

动态代理首次调用时性能较低，因为需要动态生成代理类，但后续调用差别不大。随着JDK版本升级，动态代理的性能已得到显著优化。

## 五、实际应用场景深度解析

### 5.1 Spring框架中的代理机制

Spring AOP是基于代理模式实现的，它根据目标对象是否实现接口来**自动选择JDK动态代理或CGLIB代理**。

```xml
<!-- 强制Spring使用CGLIB代理 -->
<aop:aspectj-autoproxy proxy-target-class="true"/>
```

当Bean实现接口时，Spring使用JDK动态代理；没有实现接口时使用CGLIB。这体现了动态代理在实际框架中的灵活应用。

### 5.2 MyBatis中的Mapper代理

MyBatis的Mapper接口正是通过JDK动态代理实现的：

```java
public class MapperProxyFactory<T> {
    public T newInstance(SqlSession sqlSession) {
        final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);
        return newInstance(mapperProxy);
    }
    
    protected T newInstance(MapperProxy<T> mapperProxy) {
        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), 
                new Class[] { mapperInterface }, mapperProxy);
    }
}
```

这种设计使得我们只需编写Mapper接口，而不需要实现类，MyBatis会在运行时自动生成实现。

### 5.3 RPC框架中的远程代理

远程过程调用（RPC）框架可以看作代理模式的一种应用。客户端调用本地代理方法时，代理会将调用转发给远程服务：

```java
// 客户端使用的服务接口
public interface UserService {
    User getUserById(Long id);
}

// RPC代理处理远程调用细节
public class RpcProxy implements InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args) {
        // 封装请求数据
        RpcRequest request = new RpcRequest(method.getName(), args);
        // 发送网络请求到远程服务
        return sendRequestToRemoteService(request);
    }
}
```

这体现了代理模式在**解耦客户端和远程服务**方面的价值。

## 六、设计模式与架构思想

### 6.1 代理模式与AOP编程

AOP（面向切面编程）的核心思想正是基于动态代理实现的。通过代理，我们可以将横切关注点（如日志、事务、安全等）与业务逻辑分离。

假设我们在多个服务方法中都需要添加日志记录，使用动态代理可以避免在每个方法中重复编写日志代码：

```java
public class LoggingHandler implements InvocationHandler {
    private Object target;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 方法执行前记录日志
        System.out.println("开始执行方法: " + method.getName());
        
        long startTime = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTime = System.currentTimeMillis();
        
        // 方法执行后记录日志
        System.out.println("方法执行完成，耗时: " + (endTime - startTime) + "ms");
        return result;
    }
}
```

### 6.2 代理模式的开闭原则体现

代理模式很好地体现了**开闭原则**（对扩展开放，对修改关闭）。我们可以在不修改原有类的情况下，通过代理添加新功能。

比如，想要给一个已有的服务添加缓存功能，可以创建一个缓存代理：

```java
public class CacheProxy implements InvocationHandler {
    private Object target;
    private Map<String, Object> cache = new HashMap<>();
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String cacheKey = generateCacheKey(method, args);
        
        // 如果缓存中存在，直接返回缓存结果
        if (cache.containsKey(cacheKey)) {
            return cache.get(cacheKey);
        }
        
        // 否则调用真实方法，并缓存结果
        Object result = method.invoke(target, args);
        cache.put(cacheKey, result);
        return result;
    }
}
```

## 七、总结与展望

代理模式作为结构型设计模式的重要成员，在实际开发中有着广泛的应用。静态代理简单直接，适用于固定场景；动态代理灵活强大，更适合框架开发。

随着云原生和微服务架构的普及，代理模式在服务网格（Service Mesh）、API网关等领域的应用越来越广泛。现代系统中的边车模式（Sidecar Pattern）本质上也是一种代理模式的应用。

理解代理模式不仅有助于我们日常开发，更是深入理解现代框架设计思想的关键。希望本文能帮助你全面掌握静态代理和动态代理的区别与应用，在实际工作中灵活运用这一强大工具。

## 参考资料

1. https://developer.baidu.com/article/details/2689165
2. https://blog.csdn.net/qq_42102911/article/details/130257613
3. https://m.php.cn/faq/1391186.html
4. https://blog.csdn.net/qq_41432730/article/details/121653269
5. https://bbs.huaweicloud.com/blogs/3120ac084d4743aca0501cab620a4182
6. https://blog.51cto.com/u_15335146/3493919