[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下Java并发编程利器Atomic原子类。

> 技术干货满满，一文掌握Java原子类的精髓

在Java并发编程的世界里，多线程安全是一个永恒的话题。想象一下超市排队结账的场景：如果收银系统混乱，多个顾客同时结账，结果会怎样？这就像多线程环境下的数据竞争问题。今天，我们就来聊聊Java并发包中的"排队神器"——Atomic原子类。

## 一、原子类：并发世界的秩序维护者

在并发编程中，我们常常遇到这样的问题：多个线程同时执行i++操作，结果可能不如预期。这是因为i++看似是一个操作，实际上包含读取、增加、写入三个步骤，在多线程环境下可能被中断。

传统的解决方案是使用synchronized关键字，但这就像在超市结账时给整个收银台加锁，虽然安全但效率低下。而Atomic原子类则提供了一种更高效的策略：它像是一位聪明的收银员，能够快速处理每个顾客的请求，确保不会混乱。

原子类的核心特点是**操作不可分割**，即一个操作要么完全完成，要么完全不完成，不会出现中间状态。Java的java.util.concurrent.atomic包提供了一系列原子类，让我们在不使用锁的情况下实现线程安全。

## 二、原子类的四大家族

Atomic原子类可以分为四大类别，每种都有其特定的使用场景。

### 1. 基本类型原子类

这是最常用的原子类，包括：
- **AtomicInteger**：原子更新整型
- **AtomicLong**：原子更新长整型
- **AtomicBoolean**：原子更新布尔类型

AtomicInteger基本功能使用：
```java
// 计数器场景
AtomicInteger requestCount = new AtomicInteger(0);

// 每个请求到来时
public void handleRequest() {
    // 原子性增加，不会出现并发问题
    int currentCount = requestCount.incrementAndGet();
    // 处理请求...
}
```

网站访问量统计场景示例：
```java
// 网站访问量统计场景
public class WebsiteCounter {
    private AtomicInteger pageView = new AtomicInteger(0);
    private AtomicInteger uniqueVisitor = new AtomicInteger(0);
    private AtomicBoolean isWebsiteOnline = new AtomicBoolean(true);
    
    // 页面访问，多个线程可能同时调用
    public void onPageVisit(int visitorId) {
        // 原子增加访问量
        int currentViews = pageView.incrementAndGet();
        
        // 使用CAS实现唯一访客统计
        boolean success = false;
        while (!success) {
            int currentVisitors = uniqueVisitor.get();
            if (!hasVisitedToday(visitorId)) {
                success = uniqueVisitor.compareAndSet(currentVisitors, currentVisitors + 1);
            } else {
                break;
            }
        }
        
        System.out.println("总访问量: " + currentViews + ", 独立访客: " + uniqueVisitor.get());
    }
    
    // 网站维护切换
    public void toggleMaintenanceMode() {
        boolean oldStatus = isWebsiteOnline.getAndSet(!isWebsiteOnline.get());
        System.out.println("网站状态从 " + (oldStatus ? "在线" : "离线") + 
                         " 切换到 " + (isWebsiteOnline.get() ? "在线" : "离线"));
    }
    
    private boolean hasVisitedToday(int visitorId) {
        // 模拟检查逻辑
        return false;
    }
}
```

### 2. 数组类型原子类

如果你需要原子地更新数组中的元素，可以使用：
- **AtomicIntegerArray**：原子更新整型数组的元素
- **AtomicLongArray**：原子更新长整型数组的元素
- **AtomicReferenceArray**：原子更新引用类型数组的元素

使用示例：
```java
// 多线程环境下的投票统计
AtomicIntegerArray voteCounts = new AtomicIntegerArray(10); // 10个候选人

// 为候选人投票
public void voteForCandidate(int candidateId) {
    voteCounts.getAndIncrement(candidateId);
}
```

### 3. 引用类型原子类

当需要原子更新对象引用时，这些类就非常有用：
- **AtomicReference**：原子更新对象引用
- **AtomicStampedReference**：带版本号的原子引用（解决ABA问题）
- **AtomicMarkableReference**：带标记位的原子引用

AtomicReference基本使用示例：
```java
// 缓存系统中的应用
AtomicReference<Cache> cacheRef = new AtomicReference<>();

public void updateCache(Cache newCache) {
    Cache currentCache;
    do {
        currentCache = cacheRef.get();
        // 只有在缓存未被其他线程修改时才会更新
    } while (!cacheRef.compareAndSet(currentCache, newCache));
}
```

用户会话管理使用示例：
```java
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

// 用户会话管理
public class UserSessionManager {
    private AtomicReference<UserSession> currentSession = new AtomicReference<>();
    
    // 使用AtomicStampedReference解决ABA问题
    private AtomicStampedReference<BankAccount> accountRef = 
        new AtomicStampedReference<>(null, 0);
    
    public static class UserSession {
        private String userId;
        private String username;
        private long loginTime;
        
        public UserSession(String userId, String username) {
            this.userId = userId;
            this.username = username;
            this.loginTime = System.currentTimeMillis();
        }
        
        // getters and setters
    }
    
    public static class BankAccount {
        private String accountNumber;
        private double balance;
        
        public BankAccount(String accountNumber, double balance) {
            this.accountNumber = accountNumber;
            this.balance = balance;
        }
        
        // getters and setters
    }
    
    // 原子性的会话切换
    public boolean switchUserSession(UserSession newSession) {
        UserSession oldSession = currentSession.get();
        System.out.println("尝试从会话 " + 
                          (oldSession != null ? oldSession.userId : "null") + 
                          " 切换到 " + newSession.userId);
        
        // 使用CAS确保会话切换的原子性
        boolean success = currentSession.compareAndSet(oldSession, newSession);
        if (success) {
            System.out.println("会话切换成功");
        } else {
            System.out.println("会话切换失败，可能已被其他线程修改");
        }
        return success;
    }
    
    // 转账操作，避免ABA问题
    public boolean transferMoney(BankAccount from, BankAccount to, double amount) {
        int[] stampHolder = new int[1];
        BankAccount currentAccount = accountRef.get(stampHolder);
        int currentStamp = stampHolder[0];
        
        // 模拟转账逻辑
        BankAccount newFromAccount = new BankAccount(
            from.getAccountNumber(), from.getBalance() - amount);
        BankAccount newToAccount = new BankAccount(
            to.getAccountNumber(), to.getBalance() + amount);
        
        // 使用版本戳避免ABA问题
        return accountRef.compareAndSet(from, newFromAccount, currentStamp, currentStamp + 1);
    }
}
```

### 4. 字段更新器

当你只需要原子更新某个类的字段，而不想将整个类包装成原子类时，可以使用：
- **AtomicIntegerFieldUpdater**：原子更新对象的int字段
- **AtomicLongFieldUpdater**：原子更新对象的long字段
- **AtomicReferenceFieldUpdater**：原子更新对象的引用字段

使用示例：
```java
class User {
    public volatile int age; // 必须为volatile
}

// 创建更新器
AtomicIntegerFieldUpdater<User> ageUpdater = 
    AtomicIntegerFieldUpdater.newUpdater(User.class, "age");

User user = new User();
ageUpdater.set(user, 30); // 原子性更新age字段
```

## 三、原子类的核心原理：CAS算法

Atomic原子类的魔法背后是**CAS（Compare-And-Swap）算法**，它是一种乐观锁策略。

### CAS的工作原理

CAS操作包含三个参数：
- **V**：需要读写的内存位置
- **A**：预期的原值
- **B**：想要更新的新值

CAS的伪代码实现：
```java
boolean CAS(V, A, B) {
    if (V == A) {
        V = B;
        return true; // 操作成功
    } else {
        return false; // 操作失败
    }
}
```

当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程能成功，其他线程会失败但不会阻塞，而是可以再次尝试。

### synchronized vs CAS

**synchronized**（悲观锁）：
- 假设最坏情况，每次操作都会冲突
- 采用独占方式，其他线程需要阻塞等待
- 适合竞争激烈、临界区操作复杂的场景

**CAS**（乐观锁）：
- 假设最好情况，操作通常不会冲突
- 线程失败后重试，不会阻塞
- 适合竞争不激烈、操作简单的场景

这就好比两种不同的排队策略：synchronized像是一个严格的保安，每次只允许一个人进入；CAS则像是自助服务，大家都可以尝试，如果发现冲突就重试。

## 四、ABA问题及解决方案

CAS算法虽然高效，但存在一个著名的**ABA问题**：如果一个值原来是A，变成了B，又变回A，那么CAS检查时会认为它从来没有被修改过。

### ABA问题的危害

假设一个银行账户系统：
```java
AtomicInteger account = new AtomicInteger(100);

// 线程1：尝试扣款50
new Thread(() -> {
    int current = account.get();
    // 模拟一些处理时间
    Thread.sleep(1000);
    // 此时账户可能经历了100→50→100的变化
    boolean success = account.compareAndSet(current, current - 50);
}).start();

// 线程2：先扣款再充值
new Thread(() -> {
    account.addAndGet(-50); // 100 → 50
    account.addAndGet(50);  // 50 → 100
}).start();
```

在这个例子中，线程1的CAS操作会成功，因为它检测到的值确实是100，但它不知道中间发生了100→50→100的变化。

### 解决方案

1. **AtomicStampedReference**：通过版本号解决
```java
AtomicStampedReference<Integer> account = 
    new AtomicStampedReference<>(100, 0); // 初始值100，版本号0

// 线程1尝试扣款
int[] stampHolder = new int[1];
int current = account.get(stampHolder);
int currentStamp = stampHolder[0];

// 只有值和版本号都匹配时才更新
account.compareAndSet(current, current - 50, currentStamp, currentStamp + 1);
```

2. **AtomicMarkableReference**：通过标记位解决
```java
AtomicMarkableReference<Integer> account = 
    new AtomicMarkableReference<>(100, false);

// 使用标记位来检测变化
boolean[] markHolder = new boolean[1];
int current = account.get(markHolder);
account.compareAndSet(current, current - 50, false, true); // 标记为已修改
```

## 五、实战案例：构建线程安全的堆栈

让我们通过一个实际例子来看看AtomicReference的强大之处：实现一个线程安全的堆栈。

```java
public class ConcurrentStack<T> {
    // 使用原子引用管理栈顶节点
    private AtomicReference<Node<T>> top = new AtomicReference<>();
    
    // 入栈操作
    public void push(T item) {
        Node<T> newHead = new Node<>(item);
        Node<T> oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead)); // CAS直到成功
    }
    
    // 出栈操作
    public T pop() {
        Node<T> oldHead;
        Node<T> newHead;
        do {
            oldHead = top.get();
            if (oldHead == null) {
                return null; // 栈为空
            }
            newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead)); // CAS直到成功
        return oldHead.item;
    }
    
    // 节点类
    private static class Node<T> {
        public final T item;
        public Node<T> next;
        
        public Node(T item) {
            this.item = item;
        }
    }
}
```

这个实现完全**无锁**，依靠CAS操作保证线程安全，在高并发环境下性能优异。

## 六、原子类的适用场景与注意事项

### 适用场景
1. **计数器**：如网站访问量统计
2. **状态标志**：如系统开关控制
3. **累积计数**：如平均值计算
4. **对象引用更新**：如缓存系统

### 注意事项
1. **ABA问题**：在重要业务场景使用带版本号的原子类
2. **性能考量**：高竞争环境下CAS频繁失败可能降低性能
3. **单一变量**：原子类保证单个变量原子性，复合操作仍需额外同步
4. **可见性保证**：字段更新器要求字段必须为volatile

## 七、总结

Java的Atomic原子类为我们提供了一种高效处理并发的工具。它们基于CAS机制，避免了传统锁的开销，在适当的场景下能显著提升性能。

就像交通管理一样，synchronized是红灯——所有车辆必须停止；而原子类像是环岛——车辆可以持续行驶，只在必要时调整。每种方法都有其适用场景，关键在于根据具体需求做出合适选择。

希望通过本文，你能对Java Atomic原子类有更深入的理解，并在实际项目中灵活运用，构建出高性能、线程安全的并发系统！

## 参考文章
1. https://blog.csdn.net/u014207606/article/details/85107752
2. https://blog.csdn.net/shuiziliu518/article/details/148479334
3. https://bbs.huaweicloud.com/blogs/400010
4. https://blog.51cto.com/u_56701/14054760
5. https://blog.csdn.net/kalman2008/article/details/18606349
6. https://juejin.cn/post/7327724773659394074
7. https://blog.51cto.com/u_16175512/12935133

* 本文主要观点基于以上参考资料，结合实际开发经验整理而成。转载请注明出处。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**

