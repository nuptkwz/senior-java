[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下：Happens-Before原则详解。

> 掌握这个原则，让你的多线程代码不再“神经错乱”

在日常开发中，你是否曾遇到过这样的诡异情况：明明单线程下运行正常的程序，在多线程环境下就变得神经兮兮？某个线程刚刚设置的值，另一个线程却读取不到？这其实都是Java内存模型（JMM）在作祟，而**Happens-Before原则**正是理解并解决这些问题的金钥匙。

## 从一个令人抓狂的bug说起

先来看段看似简单却暗藏玄机的代码：

```java
public class VisibilityProblem {
    private static boolean ready = false;
    private static int number = 0;
    
    public static void main(String[] args) {
        new Thread(() -> {
            while (!ready) {
                // 可能永远循环，看不到ready的更新
                Thread.yield();
            }
            System.out.println(number); // 可能输出0
        }).start();
        
        number = 42;
        ready = true; // 可能重排序到number赋值前
    }
}
```

运行这段代码，你可能会惊讶地发现：程序可能永远循环，或者输出0而不是42！这可不是灵异事件，而是**内存可见性**和**指令重排序**在捣鬼。

## Java内存模型（JMM）：舞台背后的导演

要理解Happens-Before，我们首先要了解Java内存模型（JMM）。想象一下，JMM就像是一位严格的导演，它规定了每个线程（演员）应该如何与主内存（剧本）和工作内存（个人剧本笔记）交互。

在JMM的世界里：

- **主内存**：所有线程共享的内存区域，存储对象实例、静态变量等共享数据
- **工作内存**：每个线程私有的内存空间，存储主内存中变量的副本

当线程需要读取共享变量时，它需要先从主内存"拷贝"数据到自己的工作内存；修改数据后，还需要将结果"刷新"回主内存。

问题就在于：如果没有明确的同步措施，一个线程的修改可能不会立即被其他线程看到。这就好比演员A修改了剧本，但导演没有及时通知其他演员，大家还在按照旧的剧本排练！

## Happens-Before原则：并发世界的交通规则

Happens-Before原则就是JMM为并发编程制定的一套"交通规则"，它定义了操作之间的偏序关系，确保一个操作的结果对另一个操作可见。

**如果操作A Happens-Before操作B，那么A的结果对B是可见的，且A的执行顺序优先于B。** 注意，这**不是**时间上的先后顺序，而是**可见性**的保证。

### 八大Happens-Before规则

#### 1. 程序顺序规则：单线程的天然顺序

在单线程内，书写顺序在前的操作Happens-Before书写顺序在后的操作。

```java
int x = 1;  // 操作A
int y = 2;  // 操作B
// A Happens-Before B
```

这很好理解，就是代码的书写顺序。但在多线程环境下，其他线程不一定能看到这个顺序！

#### 2. 监视器锁规则：锁的交接仪式

对一个锁的解锁操作Happens-Before随后对该锁的加锁操作。

```java
private final Object lock = new Object();
private int sharedData = 0;

public void writer() {
    synchronized(lock) {
        sharedData = 42; // 解锁happens-before后续加锁
    }
}

public void reader() {
    synchronized(lock) {
        System.out.println(sharedData); // 保证看到42
    }
}
```

这就像是一把钥匙的交接：只有前一个人用完锁（解锁），下一个人才能拿到锁（加锁）并使用共享资源。

#### 3. volatile变量规则：大喇叭广播

对volatile变量的写操作Happens-Before后续对该变量的读操作。

```java
private volatile boolean flag = false;
private int data = 0;

public void writer() {
    data = 42;      // 普通写
    flag = true;    // volatile写 - 就像个大喇叭广播
}

public void reader() {
    if (flag) {     // volatile读 - 听到广播
        System.out.println(data); // 保证看到42
    }
}
```

volatile变量就像是广播喇叭：写操作就像通过喇叭广播消息，读操作就像听到广播，保证所有人都能及时收到最新通知。

#### 4. 线程启动规则：前辈的嘱托

Thread.start()操作Happens-Before线程内的第一个操作。

```java
final int[] result = new int[1];
Thread t = new Thread(() -> {
    result[0] = 42; // 线程内第一个操作
});
t.start(); // start() happens-before 线程内所有操作
```

这就像是前辈对后辈的嘱托：主线程在启动子线程前的所有操作，对子线程都是可见的。

#### 5. 线程终止规则：临终遗言

线程内的最后一个操作Happens-Before其他线程检测到该线程已终止的操作（如thread.join()）。

```java
final int[] result = new int[1];
Thread t = new Thread(() -> {
    result[0] = 42; // 线程的最后操作
});
t.start();
t.join(); // 线程内操作happens-before join()返回
System.out.println(result[0]); // 保证看到42
```

这好比临终遗言：线程结束前的所有操作，在其他线程通过join()检测到该线程终止时，都是可见的。

#### 6. 中断规则：中断信号的传递

线程A调用线程B的interrupt()方法Happens-Before线程B检测到中断状态（isInterrupted()或interrupted()）。

#### 7. 传递性规则：关系的传递

如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。

#### 8. 对象终结规则：构造函数的遗产

对象的构造函数执行完毕Happens-Before其finalize()方法开始执行。

## 实战应用：Happens-Before在真实场景中的威力

### 场景一：双重检查锁定（DCL）的救赎

单例模式的双重检查锁定是Happens-Before原则的经典应用：

```java
public class Singleton {
    private static volatile Singleton instance; // 必须加volatile
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查（无锁）
            synchronized (Singleton.class) { // 加锁
                if (instance == null) { // 第二次检查
                    instance = new Singleton(); // 关键步骤！
                }
            }
        }
        return instance;
    }
}
```

为什么instance必须用volatile修饰？因为new Singleton()不是一个原子操作，它包含：

1. 分配内存空间
2. 初始化对象
3. 将instance引用指向分配的内存地址

如果没有volatile，步骤2和3可能被重排序，导致其他线程获取到未完全初始化的对象！volatile通过Happens-Before规则禁止这种重排序。

### 场景二：并发集合的安全发布

ConcurrentHashMap如何保证线程安全？看看它的Node设计：

```java
static class Node<K,V> {
    final int hash;
    final K key;
    volatile V val; // volatile保证可见性
    volatile Node<K,V> next; // volatile保证链表操作可见性
    
    // 构造函数
    Node(int hash, K key, V val, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.val = val;
        this.next = next;
    }
}
```

通过将value和next指针声明为volatile，ConcurrentHashMap确保了读操作无需加锁就能看到最新值，极大提升了并发性能。

### 场景三：无锁编程的利器

基于volatile的无锁计数器：

```java
public class VolatileCounter {
    private volatile int count = 0;
    
    public void increment() {
        count++; // 不是原子操作，但有可见性保证
    }
    
    public int getCount() {
        return count; // 保证看到最新值
    }
}
```

虽然count++不是原子操作，但volatile确保了可见性。对于更高性能的需求，可以使用AtomicInteger，它内部利用了CAS（Compare-And-Swap）和volatile的Happens-Before语义。

## 内存屏障：Happens-Bear原则的物理实现

Happens-Before原则在底层是通过**内存屏障**（Memory Barrier）实现的。内存屏障就像是给CPU和编译器设置的"路障"，阻止指令重排序。

主要的内存屏障类型包括：

- **LoadLoad屏障**：确保Load1先于Load2及后续加载操作
- **StoreStore屏障**：确保Store1写入对其他处理器可见先于Store2
- **LoadStore屏障**：确保Load1先于Store2及后续存储操作
- **StoreLoad屏障**：全能屏障，开销最大但功能最强

当写入volatile变量时，JVM会在写操作后插入StoreStore屏障和StoreLoad屏障；当读取volatile变量时，会在读操作前插入LoadLoad屏障和LoadStore屏障。

## 常见误区与注意事项

### 误区一：Happens-Before等于时间先后

**错误观念**：如果操作A Happens-Before操作B，那么A一定在时间上先于B执行。

**事实**：Happens-Before是可见性的保证，不是时间顺序的保证。只要B能看到A的结果，就满足Happens-Before，无论实际执行时间如何。

### 误区二：volatile能保证原子性

**错误观念**：volatile能保证复合操作（如count++）的原子性。

**事实**：volatile只能保证单个读/写的原子性和可见性，对于复合操作，仍需使用synchronized或原子类。

### 误区三：Happens-Bear是万能的

**错误观念**：只要遵守Happens-Before原则，就能解决所有并发问题。

**事实**：Happens-Before主要解决可见性和有序性问题，但并发编程还包括原子性、死锁等问题，需要综合运用各种同步工具。

## 总结

Happens-Before原则是Java并发编程的基石，它通过八条核心规则为多线程环境下的内存可见性和有序性提供了重要保证。理解并熟练运用这些规则，能够帮助我们：

1.  **编写正确的并发代码**，避免内存可见性问题
2.  **理解并发工具的原理**，如synchronized、volatile、并发集合等
3.  **进行有效的并发调试**，快速定位和解决并发问题
4.  **设计高性能的并发架构**，在保证正确性的前提下提升性能

记住，在并发编程的世界里，Happens-Before原则就像交通规则一样重要：虽然遵守规则不一定能保证绝对安全，但不遵守规则几乎肯定会出问题！

希望本文能帮助你更好地理解Happens-Before原则，让你的多线程代码更加健壮和高效。如果你有相关问题或经验分享，欢迎在评论区留言讨论！

## 参考文章

1.  https://blog.csdn.net/qq_37347855/article/details/148701980
2.  https://blog.csdn.net/sinat_41617212/article/details/154804427
3.  https://blog.csdn.net/weixin_42373241/article/details/137282588

*本文主要观点基于以上参考资料，结合实际开发经验整理而成。转载请注明出处。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**

