[toc]

大家好，我是你们的技术老友**科威舟**，今天聊聊DCL单例模式中volatile的关键作用。很多人以为加了synchronized就万事大吉，殊不知背后隐藏着一个多线程陷阱。

> 你以为加了synchronized就安全了？殊不知指令重排序这个幕后黑手正在窥探你的单例对象！

## 一、DCL单例模式：看似完美的实现

先来看一个典型的DCL（Double-Checked Locking）单例实现：

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // 私有构造函数
    }
    
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

看起来很完美，对吧？两次检查，一次加锁，既保证了线程安全，又避免了每次调用都同步的性能开销。

但**问题就出在`instance = new Singleton()`这行代码上**！

## 二、罪魁祸首：指令重排序

且慢，让我们先做个比喻。假设你要装修房子（创建对象），正常步骤是：

1. 清理场地（分配内存）
2. 装修房子（初始化对象）
3. 挂上门牌号（对象引用赋值）

但编译器这个"急脾气"工头为了效率，可能会重新排列步骤：

1. 清理场地（分配内存）
   2.**先挂上门牌号**（对象引用赋值）
3. 然后才装修房子（初始化对象）

在单线程环境下，这种重排没问题，因为最终结果一致。但在多线程环境下，问题就大了！

具体到代码层面，`instance = new Singleton()`这行代码实际上包含三个关键步骤：

```java
memory = allocate();    // 1.分配对象内存空间
ctorInstance(memory);   // 2.初始化对象
instance = memory;      // 3.设置instance指向刚分配的内存地址
```

由于步骤2和步骤3之间没有数据依赖关系，编译器或处理器可能会对它们进行重排序，变成：

```java
memory = allocate();    // 1.分配对象内存空间
instance = memory;     // 3.设置instance指向刚分配的内存地址（此时对象还未初始化！）
ctorInstance(memory);  // 2.初始化对象
```

## 三、多线程场景下的灾难

假设线程A执行到`instance = new Singleton()`，并且发生了指令重排序。

当线程A执行完步骤1和步骤3（即instance已经不为null），但尚未执行步骤2（对象未初始化）时，线程B调用getInstance()。

线程B发现instance不为null（因为线程A已经设置了instance指向内存地址），于是直接返回instance。但此时instance指向的对象还没有被初始化！

结果就是：线程B使用了一个**半初始化状态的对象**，这可能导致各种不可预知的问题，如空指针异常、数据不一致等。

## 四、volatile：拯救DCL的关键先生

这就是volatile大显身手的时候了！只需简单修改：

```java
private static volatile Singleton instance;
```

volatile关键字通过两个机制确保线程安全：

### 1. 禁止指令重排序

volatile通过**内存屏障**（Memory Barrier）阻止指令重排序。具体来说，在volatile写操作前后会插入内存屏障：

- StoreStore屏障：保证volatile写之前的普通写操作不会重排序到volatile写之后
- StoreLoad屏障：保证volatile写之后的操作不会重排序到volatile写之前

这就确保了对象初始化操作的顺序不会被重排。

### 2. 保证可见性

volatile保证了不同线程对变量修改的可见性。当一个线程修改了volatile变量，新值会**立即刷新到主内存**，其他线程读取时会**直接从主内存获取最新值**。

## 五、实战场景：为什么这很重要

### 场景1：配置管理器

假设你有一个配置管理器单例：

```java
public class ConfigManager {
    private Map<String, String> configs;
    
    private ConfigManager() {
        // 耗时操作：从数据库加载配置
        configs = loadConfigsFromDB(); 
    }
    
    public static ConfigManager getInstance() { /* DCL实现 */ }
}
```

如果没有volatile，其他线程可能拿到一个configs为null的ConfigManager实例，导致空指针异常。

### 场景2：数据库连接池

```java
public class ConnectionPool {
    private List<Connection> connections;
    
    private ConnectionPool() {
        connections = new ArrayList<>();
        // 初始化连接
        for (int i = 0; i < 10; i++) {
            connections.add(createConnection());
        }
    }
}
```

指令重排序可能导致connections未初始化完成就被其他线程使用，后果不堪设想！

## 六、不只是单例：DCL的其他应用场景

DCL模式不仅用于单例，还可以用于其他需要延迟初始化的场景：

1. **延迟初始化重型资源**（如缓存、连接池）
2. **静态变量的懒加载**
3. **惰性加载的缓存系统**

但请记住：无论哪种场景，**volatile都是确保线程安全的关键**！

## 七、总结

DCL单例模式需要volatile修饰实例对象，主要原因如下表所示：

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 指令重排序 | 对象初始化步骤可能被重排序，导致其他线程拿到不完整对象 | volatile通过内存屏障禁止指令重排序 |
| 可见性问题 | 一个线程修改instance后，其他线程可能无法立即看到 | volatile保证修改立即对其他线程可见 |
| 部分初始化 | 对象处于半初始化状态，某些字段可能为默认值 | volatile确保对象完全初始化后才可见 |

虽然指令重排序导致的问题出现的概率较低（可能百万次才出现一次），但一旦发生，**调试难度极大**。因此，为DCL单例加上volatile是必要的防御性编程措施。

记住：在多线程世界，**看似安全的地方往往隐藏着最危险的陷阱**。使用DCL单例时，别忘了请volatile这个"护身符"！

## 参考资料

1. [【Java面试题】DCL单例模式设计为什么需要volatile修饰实例对象]
2. [【volatile】volatile引出的思考？到底是什么？]
3. [【Java】双重检查锁模式的单例模式（DCL懒汉式）]
4. [DCL单例模式设计为什么需要volatile修饰实例对象]
5. [单例DCL需要加volatile关键字吗]
6. [volatile和synchronized的区别]
7. [面试官：双重检查单例要不要加volatile？详解来了]
8. [实现线程安全的单例模式：原理、方法与双检锁注意事项]
9. [DCL只是用来创建单例吗？]
10. [单例模式---DCL懒汉式]

希望这篇文章能帮助你理解DCL单例模式中volatile的重要性。如果你有任何问题或见解，欢迎在评论区留言讨论！

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**

