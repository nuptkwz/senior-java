[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下Java JUC包中的CopyOnWriteArraySet原理。

> 如何在高并发读取场景中既保证线程安全又提升性能？CopyOnWriteArraySet或许正是你要找的解决方案。

在多线程编程的世界里，**线程安全**始终是我们需要直面的挑战。当涉及到共享集合时，这种挑战尤为突出。今天，我们要深入剖析的是一位在并发编程中不可或缺的"**特长生**"——CopyOnWriteArraySet。

## 什么是CopyOnWriteArraySet？

简单来说，CopyOnWriteArraySet是Java并发包(java.util.concurrent)中提供的一个**线程安全的Set实现**。它与众不同之处在于采用了"**写时复制**"（Copy-On-Write）策略，这意味着每次修改操作（如添加、删除元素）都会创建底层数组的一个新副本，而读操作则直接在原数组上进行。

想象一下图书馆的管理方式：当有人只想查阅书籍（读操作）时，可以直接进入书库浏览；但当需要增加或下架书籍（写操作）时，管理员会先创建一个完整的书库副本，在副本上进行修改，最后再用修改后的副本替换原始书库。这样，查阅者永远不会被阻塞，但修改操作的成本较高。

## 核心原理深度剖析

### 底层数据结构

CopyOnWriteArraySet的巧妙之处在于其内部实现：它**完全依赖CopyOnWriteArrayList**作为其存储结构。

```java
public class CopyOnWriteArraySet<E> extends AbstractSet<E>
    implements java.io.Serializable {
    // 内部使用CopyOnWriteArrayList来存储元素
    private final CopyOnWriteArrayList<E> al;
    
    public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList<E>();
    }
}
```

这里就产生了一个有趣的问题：CopyOnWriteArrayList本身允许元素重复，而Set要求元素唯一。CopyOnWriteArraySet如何解决这一矛盾？

答案是它通过调用CopyOnWriteArrayList的`addIfAbsent`方法来确保元素的唯一性。

### 写时复制机制详解

**添加元素**的流程体现了写时复制的精髓：

```java
public boolean add(E e) {
    // 调用addIfAbsent方法，确保元素不存在时才添加
    return al.addIfAbsent(e);
}
```

`addIfAbsent`方法内部会先检查元素是否已存在，只有在元素不存在时才会执行添加操作。添加过程需要获取**可重入锁**，然后创建原数组的副本，在新副本上添加元素，最后将副本设置为新的当前数组。

这一过程保证了写操作的**原子性和线程安全**，但代价是每次写操作都需要复制整个数组，因此写操作的性能与数组大小成正比。

### 迭代器的弱一致性

CopyOnWriteArraySet的迭代器具有**弱一致性**特征，这意味着迭代器创建时会获取当前数组的快照，在迭代过程中不会反映其他线程对集合的修改。这避免了ConcurrentModificationException异常，但代价是可能遍历到过期的数据。

```java
public Iterator<E> iterator() {
    // 返回一个基于当前数组快照的迭代器
    return al.iterator();
}
```

## 与其它容器的性能对比

为了更直观地理解CopyOnWriteArraySet的特性，我们通过一个表格比较它与其它常见容器的区别：

| 特性 | HashSet | ConcurrentHashMap.KeySetView | CopyOnWriteArraySet |
|------|---------|-----------------------------|---------------------|
| **读性能** | O(1) | O(1) | O(n)但无锁 |
| **写性能** | O(1) | O(1)带锁竞争 | O(n)复制开销 |
| **内存消耗** | 最低 | 中等 | 较高（写时复制） |
| **迭代器一致性** | 弱一致性 | 弱一致性 | 强一致性（快照） |
| **适用场景** | 单线程环境 | 高频读写 | 低频写+高频读 |

从对比中可以看出，CopyOnWriteArraySet在**读多写少**的场景中具有明显优势，特别是在需要频繁遍历且写操作较少的并发环境中。

## 实际应用场景

### 1. 配置信息管理

在大型系统中，配置信息通常只在启动时加载，之后会被多个线程频繁读取，但极少修改。使用CopyOnWriteArraySet存储配置项，可以保证在高并发读取时的性能。

```java
public class ConfigurationManager {
    private final CopyOnWriteArraySet<ConfigListener> listeners = 
        new CopyOnWriteArraySet<>();
    
    // 添加配置监听器（写操作少）
    public void addListener(ConfigListener listener) {
        listeners.add(listener);
    }
    
    // 通知所有监听器（读操作多）
    public void fireConfigChanged(ConfigEvent event) {
        for (ConfigListener listener : listeners) {
            listener.onConfigChanged(event);
        }
    }
}
```

### 2. 在线用户状态收集器

电商平台需要实时跟踪在线用户状态，这类场景中**读取频率远高于写入频率**。

```java
public class OnlineUserManager {
    private final CopyOnWriteArraySet<Long> onlineUsers = 
        new CopyOnWriteArraySet<>();
    
    // 用户登录（写操作）
    public boolean userLogin(Long userId) {
        boolean added = onlineUsers.add(userId);
        if (added) {
            log.info("用户{}登录成功，当前在线人数：{}", userId, onlineUsers.size());
        }
        return added;
    }
    
    // 获取在线用户列表（读操作）
    public Set<Long> getOnlineUsers() {
        return Collections.unmodifiableSet(onlineUsers);
    }
}
```

### 3. 事件监听器管理

GUI框架或事件驱动系统中，监听器通常在初始化时注册，之后主要进行遍历操作以通知事件，这正是CopyOnWriteArraySet的用武之地。

## 实战案例：高并发在线用户监测

以下是一个基于Spring Boot的在线用户监测系统完整示例，展示了CopyOnWriteArraySet在生产环境中的应用：

```java
@Component
public class OnlineUserManager {
    private final CopyOnWriteArraySet<Long> onlineUsers = new CopyOnWriteArraySet<>();
    private final ConcurrentMap<Long, Long> lastHeartbeat = new ConcurrentHashMap<>();
    private static final long HEARTBEAT_TIMEOUT = 300_000; // 5分钟
    
    // 用户登录
    public boolean userLogin(Long userId) {
        boolean result = onlineUsers.add(userId);
        if (result) {
            lastHeartbeat.put(userId, System.currentTimeMillis());
        }
        return result;
    }
    
    // 心跳保活
    public void refreshHeartbeat(Long userId) {
        if (onlineUsers.contains(userId)) {
            lastHeartbeat.put(userId, System.currentTimeMillis());
        }
    }
    
    // 定时清理超时用户
    public void cleanExpiredUsers() {
        long now = System.currentTimeMillis();
        for (Long userId : onlineUsers) {
            Long lastTime = lastHeartbeat.get(userId);
            if (lastTime != null && now - lastTime > HEARTBEAT_TIMEOUT) {
                onlineUsers.remove(userId);
                lastHeartbeat.remove(userId);
            }
        }
    }
}
```

这个实现能够支持**5000+ QPS的并发读取压力**，同时保证用户登录/登出操作的原子性。

## 局限性及注意事项

尽管CopyOnWriteArraySet在特定场景下表现优秀，但它并非万能钥匙，存在以下局限性：

1.  **内存开销大**：写操作需要复制整个数组，内存占用较高
2.  **实时性弱**：读操作可能无法立即看到其他线程的最新修改
3.  **写性能随数据量增长而下降**：不适合存储大量数据且写操作频繁的场景

## 总结

CopyOnWriteArraySet是Java并发包中一颗璀璨的明珠，它在**读多写少**的并发场景中表现卓越。通过写时复制机制，它实现了读操作的无锁并发，特别适合配置管理、事件监听、会话管理等场景。

但是，选择数据结构时一定要根据实际应用场景权衡利弊。如果你的应用**写操作频繁**或**数据量巨大**，那么ConcurrentHashMap.KeySetView可能是更好的选择。

**技术选型的艺术不在于选择最先进的技术，而在于选择最合适的技术。** CopyOnWriteArraySet的存在再次证明了这一原则：在正确的场景下，即使看似"低效"的复制整个数组的策略，也能成为解决高并发问题的利器。

## 参考文章

1.  [Java CopyOnWriteArraySet源码深度解析 - CSDN]
2.  [深度剖析 Java CopyOnWriteArraySet：源码级使用原理揭秘 - 51CTO]
3.  [揭秘 Java CopyOnWriteArraySet：深入源码剖析使用原理 - CSDN]
4.  [CopyOnWriteArraySet - CSDN]
5.  [JUC集合类 CopyOnWriteArraySet源码解析 JDK8 - CSDN]
6.  [基于CopyOnWriteArraySet的高并发在线用户状态收集器架构设计 - CSDN]
7.  [如何在Java中使用CopyOnWriteArraySet - PHP中文网]

* 本文主要观点基于以上参考资料，结合实际开发经验整理而成。转载请注明出处。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**

