[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下Java中的锁机制。

> 技术干货满满，一文带你了解Java中的锁。

在并发编程的世界里，锁是保障线程安全的重要工具。但面对琳琅满目的锁机制，很多开发者都会感到困惑。今天，我们将深入剖析Java中的各种锁机制，带你打通并发编程的"任督二脉"。

## 一、锁的基本概念：为什么需要锁？

在多线程环境下，多个线程同时访问共享资源会导致**数据竞争**问题。锁作为一种同步机制，可以确保同一时间只有一个线程能够访问共享资源，从而保证数据的一致性。

可以把锁想象成**卫生间钥匙**：当一个使用者拿到钥匙进入卫生间时，其他人必须等待；使用完毕后归还钥匙，下一个人才能使用。这种机制避免了尴尬的"撞车"情况。

## 二、锁的分类体系

Java中的锁可以按照不同的维度进行分类，让我们通过一个表格全面了解锁的家族体系：

| 分类维度 | 锁类型 | 典型实现 | 特点 |
|---------|-------|---------|------|
| 锁的性质 | 悲观锁 | synchronized, ReentrantLock | 认为会发生并发冲突，先加锁再访问 |
|  | 乐观锁 | CAS, AtomicInteger | 认为不会发生冲突，先修改再检查 |
| 锁的粒度 | 表锁 | 数据库表锁 | 锁定整张表，粒度粗 |
|  | 行锁 | 数据库行锁 | 锁定特定行，粒度细 |
| 读写特性 | 读写锁 | ReentrantReadWriteLock | 读共享，写独占 |
|  | 排它锁 | synchronized, ReentrantLock | 完全独占 |
| 锁状态 | 偏向锁 | synchronized优化 | 偏向第一个访问线程 |
|  | 轻量级锁 | synchronized优化 | CAS实现，避免线程阻塞 |
|  | 重量级锁 | synchronized最终形态 | 基于操作系统互斥量 |
| 等待机制 | 自旋锁 | CAS自旋 | 循环尝试获取锁 |
| 范围 | 意向锁 | 数据库意向锁 | 表明"意图"加行级锁 |

## 三、核心锁机制深度剖析

### 1. 悲观锁 vs 乐观锁

**悲观锁**就像一位**过度谨慎的管家**，总是假设最坏情况——认为每次访问共享资源时都会有其他线程修改数据。因此，它在操作前总会先加锁。

```java
// 悲观锁示例 - synchronized
public synchronized void transferMoney(Account from, Account to, double amount) {
    // 转账逻辑
    from.withdraw(amount);
    to.deposit(amount);
}
```

**乐观锁**则像一位**乐观的协调者**，假设操作期间不会发生冲突，只在提交时检查数据是否被修改。

```java
// 乐观锁示例 - CAS
public class OptimisticLockExample {
    private AtomicInteger balance = new AtomicInteger(100);
    
    public boolean withdraw(int amount) {
        int current;
        do {
            current = balance.get();
            if (current < amount) {
                return false;
            }
        } while (!balance.compareAndSet(current, current - amount));
        return true;
    }
}
```

**适用场景**：悲观锁适合**写多读少**的高冲突场景；乐观锁适合**读多写少**的低冲突场景。

### 2. synchronized的锁升级过程

synchronized的优化过程就像**职场新人的成长路径**：

**偏向锁**（新人期）：当只有一个线程访问时，JVM会偏向这个线程，后续访问无需同步操作。这就像部门里只有一个员工，所有资源都优先给他使用。

**轻量级锁**（成长期）：当有轻微竞争时，线程通过CAS操作尝试获取锁，避免线程阻塞。如同几个同事协作，通过简单沟通就能解决问题。

**重量级锁**（成熟期）：当竞争激烈时，锁升级为重量级锁，未获取到锁的线程会被阻塞。这就像重要项目需要正式会议和严格流程来协调资源。

### 3. 读写锁（ReadWriteLock）

读写锁采用了"**多读单写**"的策略，非常适合读多写少的场景。

```java
public class ReadWriteCache {
    private Map<String, Object> cache = new HashMap<>();
    private ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public Object get(String key) {
        rwLock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void put(String key, Object value) {
        rwLock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}
```

这种设计允许多个读线程同时访问，但写线程独占访问，大大提高了系统的并发性能。

### 4. 自旋锁

自旋锁的理念是：**如果锁的持有时间很短，那么等待锁的线程稍作循环等待（自旋）可能比挂起更高效**。

就像等电梯时，如果知道电梯马上就到，我们会选择在门口等待（自旋）而不是回工位（线程挂起）。

```java
public class SpinLock {
    private AtomicBoolean locked = new AtomicBoolean(false);
    
    public void lock() {
        // 自旋等待
        while (!locked.compareAndSet(false, true)) {
            // 自旋期间可以执行一些轻量级操作
        }
    }
    
    public void unlock() {
        locked.set(false);
    }
}
```

但自旋锁要注意**自旋时间**，过长会浪费CPU资源。

## 四、数据库锁机制

### 1. 行锁 vs 表锁

**行锁**就像**精确制导导弹**，只锁定需要的数据行，其他行仍可正常访问。这提供了更好的并发性，但管理开销较大。

**表锁**则是**范围轰炸**，直接锁定整张表，管理简单但并发性差。

**实战场景**：在用户余额更新时使用行锁，避免全表锁定影响其他用户操作。

### 2. 间隙锁（Gap Lock）与临键锁（Next-Key Lock）

间隙锁锁定索引记录之间的间隔，防止幻读；临键锁则是行锁+间隙锁的组合。

比如，防止在事务执行过程中，有其他插入操作在条件范围内添加新记录。

### 3. 意向锁

意向锁是一种**声明式锁**，表示"我打算在这个资源上加更细粒度的锁"。这就像在会议室门口挂"预定"牌子，表明后续会详细使用。

## 五、分布式锁：超越单机范畴

在分布式系统中，单机锁已无法满足需求，我们需要分布式锁来协调多个节点。

### 1. 基于Redis的分布式锁

```java
public class RedisDistributedLock {
    public boolean tryLock(String lockKey, String requestId, int expireTime) {
        return redisTemplate.opsForValue()
            .setIfAbsent(lockKey, requestId, expireTime, TimeUnit.SECONDS);
    }
    
    public boolean unlock(String lockKey, String requestId) {
        // 使用Lua脚本保证原子性
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) else return 0 end";
        return redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), 
                                   Collections.singletonList(lockKey), requestId) == 1;
    }
}
```

### 2. 基于Zookeeper的分布式锁

Zookeeper通过创建临时顺序节点实现公平的分布式锁，像**银行排队机**一样保证先来后到。

## 六、实战案例：转账业务中的锁应用

让我们通过一个完整的转账案例，展示不同锁的应用：

```java
@Service
public class TransferService {
    // 使用ReentrantLock保证账户操作的原子性
    private final Lock lock = new ReentrantLock(true); // 公平锁
    
    @Transactional
    public boolean transfer(Account from, Account to, BigDecimal amount) {
        if (lock.tryLock()) {
            try {
                // 检查余额是否充足
                if (from.getBalance().compareTo(amount) >= 0) {
                    from.debit(amount);
                    to.credit(amount);
                    accountRepository.save(from);
                    accountRepository.save(to);
                    return true;
                }
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
}
```

在这个案例中，我们结合了**数据库事务**、**ReentrantLock**和**余额检查**，确保了转账操作的安全性和一致性。

## 七、避坑指南与最佳实践

1.  **死锁预防**：避免嵌套锁，按固定顺序获取锁，使用定时锁
2.  **锁粒度**：尽量减小锁的粒度，只锁定必要的代码块
3.  **锁分离**：读写分离，使用ReadWriteLock替代独占锁
4.  **性能监控**：关注锁竞争情况，避免不必要的锁升级

## 八、总结

Java的锁机制是一个庞大而精妙的体系，从简单的synchronized到复杂的分布式锁，每种锁都有其适用场景。合理选择和使用锁，是构建高并发应用的关键。

记住：**没有最好的锁，只有最合适的锁**。明智地选择锁策略，让你的应用在并发场景下游刃有余！

## 参考文章

1. https://developer.aliyun.com/article/1441144
2. https://blog.csdn.net/weixin_44817884/article/details/136677898
3. https://blog.csdn.net/u013738122/article/details/105474728
4. https://m.php.cn/zh-tw/faq/556205.html
5. https://docs.pingcode.com/baike/275423
6. https://docs.pingcode.com/baike/390005
7. https://blog.51cto.com/u_16175498/13407976

希望这篇文章能帮助你更好地理解Java中的各种锁机制！如有疑问，欢迎留言讨论。

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**

