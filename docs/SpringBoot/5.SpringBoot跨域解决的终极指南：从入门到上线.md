[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下常用的Linux命令是由什么英文缩写而来的。

> 不止是解决方案，更是解决思路的深度剖析

在前后端分离的开发模式中，跨域问题就像是一道看不见的墙，让前端和后端近在咫尺却难以"握手"。今天，我们将深入探讨SpringBoot中解决跨域问题的多种方案，帮你彻底攻克这一难点。

## 一、什么是跨域？一个有趣的比喻

想象一下，你住在一个小区（前端页面）里，想点隔壁小区（后端接口）的外卖。保安（浏览器）说："不行，你不是我们小区的，我不能放行！"这就是浏览器的**同源策略**在起作用。

当协议、域名或端口有任何不同时，浏览器就会阻止这样的"跨小区"请求，这就是**跨域问题**。

**同源策略的"三要素"**：
- 协议（http/https）
- 域名（包括子域名）
- 端口号

只有这三者完全一致，浏览器才会认为是同源请求。例如，`http://localhost:8080` 请求 `http://localhost:8081`，虽然域名相同，但端口不同，就属于跨域请求。

## 二、为什么需要跨域解决？现实开发中的痛点

在前后端分离成为主流的今天，前端开发服务器通常运行在一个端口（如3000），而后端API服务器运行在另一个端口（如8080）。这就导致了开发过程中的跨域问题。

更复杂的是，生产环境中前端可能部署在CDN上，而后端API有自己的域名，这使得跨域成为必须解决的问题，而不是可以回避的技术难点。

## 三、SpringBoot跨域解决方案大全

### 3.1 局部解决方案：@CrossOrigin注解

最简单的解决方案，适合只需要少量接口支持跨域的场景。

```java
@RestController
public class UserController {
    
    // 允许所有来源访问该接口
    @CrossOrigin(origins = "*")
    @GetMapping("/user")
    public String getUser() {
        return "User Info";
    }
    
    // 精确控制允许的来源和方法
    @CrossOrigin(origins = "http://localhost:8080", 
                 methods = RequestMethod.POST)
    @PostMapping("/update")
    public String updateUser() {
        return "Update Success";
    }
}
```

**适用场景**：API数量少，跨域需求简单的项目。

**优点**：配置简单，直接明了
**缺点**：当需要跨域的接口多时，配置冗余

### 3.2 全局配置（推荐）：WebMvcConfigurer

这是**最常用**的解决方案，可以一次性配置整个应用的跨域规则。

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")  // 所有接口
                .allowedOriginPatterns("*") // 允许所有来源
                .allowedMethods("GET", "POST", "PUT", "DELETE") // 允许的HTTP方法
                .allowedHeaders("*") // 允许所有请求头
                .allowCredentials(true) // 允许携带Cookie
                .maxAge(3600); // 预检请求缓存时间（秒）
    }
}
```

**关键参数解析**：
- `allowedOriginPatterns("*")`：允许的域名，`*`表示全部允许
- `allowCredentials(true)`：是否允许发送Cookie等凭证信息
- `maxAge(3600)`：预检请求的缓存时间，减少OPTIONS请求

**适用场景**：大多数前后端分离项目，特别是API接口较多的场景。

### 3.3 过滤器方案：更灵活的全局控制

过滤器方案在请求处理的早期阶段介入，提供更细粒度的控制。

```java
@Configuration
public class CorsFilterConfig {
    
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        
        config.addAllowedOriginPattern("*");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);
        
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

**适用场景**：需要精细控制跨域逻辑，或项目中使用过滤器链进行处理的场景。

### 3.4 Spring Security项目中的特殊配置

当项目使用了Spring Security时，需要额外的配置：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().and() // 启用CORS
            .csrf().disable()
            .authorizeRequests()
            .anyRequest().authenticated();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("http://localhost:8080"));
        config.setAllowedMethods(Arrays.asList("GET", "POST"));
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

**重要**：在Spring Security项目中，必须显式调用`http.cors()`来启用CORS支持。

### 3.5 配置文件方案：Spring Boot 2.4+

从Spring Boot 2.4开始，可以在`application.yml`中配置CORS：

```yaml
spring:
  web:
    cors:
      allowed-origins: http://localhost:8080
      allowed-methods: GET, POST, PUT, DELETE
      allow-credentials: true
      max-age: 3600
```

这种方案配置简单，适合简单的跨域需求。

## 四、实战中的坑与解决方案

### 4.1 SessionId每次不同的问题

在跨域请求中，你可能会遇到每次请求的SessionId都不同的问题。这是因为**浏览器默认不会在跨域请求中发送凭据**。

**解决方案**：
前端需要设置`withCredentials`，后端需要设置`allowCredentials(true)`并且不能使用`*`作为允许的源。

**前端代码示例**：
```javascript
// Axios示例
axios.get('http://api.example.com/data', {
  withCredentials: true
});

// jQuery Ajax示例
$.ajax({
  url: 'http://api.example.com/data',
  xhrFields: {
    withCredentials: true
  }
});
```

**后端配置**：
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:8080") // 必须是具体域名，不能是*
                .allowCredentials(true); // 允许凭证
    }
}
```

### 4.2 OPTIONS预检请求处理

对于复杂请求（如Content-Type为application/json的POST请求），浏览器会先发送OPTIONS预检请求。**Spring Boot会自动处理OPTIONS请求**，但你需要注意：

1. 确保你的安全配置不会拦截OPTIONS请求
2. 设置适当的`maxAge`减少预检请求次数

### 4.3 生产环境的安全配置

在生产环境中，**切忌使用通配符***，应该明确指定允许的域名：

```java
@Configuration
public class ProdCorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("https://www.example.com", "https://api.example.com")
                .allowedMethods("GET", "POST")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

## 五、不同方案的优先级与选择策略

当多种配置同时存在时，**优先级顺序**为：

1. 过滤器（CorsFilter）配置 - **最高优先级**
2. 全局配置（WebMvcConfigurer）
3. @CrossOrigin注解 - **最低优先级**

**选择策略建议**：
- 小型项目：使用@CrossOrigin注解
- 标准前后端分离项目：使用全局配置（WebMvcConfigurer）
- 需要精细控制或集成Spring Security：使用过滤器配置
- 简单演示或内部工具：使用配置文件方式

## 六、真实案例：Vue3 + Spring Boot项目跨域排查

这是一个真实的开发场景：Vue3前端运行在`http://localhost:8080`，Spring Boot后端运行在`http://localhost:8081`。尽管后端配置了@CrossOrigin注解，但前端仍然报CORS错误。

**排查过程**：
1. 检查后端CORS配置 - 正常
2. 使用Postman测试接口 - 正常，说明后端逻辑无误
3. 检查浏览器控制台 - 发现响应头中没有CORS相关字段
4. 最终发现：项目使用了Nginx反向代理，但Nginx配置中缺少CORS头

**Nginx解决方案**：
```nginx
location /api {
    proxy_pass http://localhost:8080;
    add_header 'Access-Control-Allow-Origin' '*';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
    add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
}
```

这个案例告诉我们：**跨域问题可能不仅限于后端配置，还需要考虑整个请求链路的配置**。

## 七、总结

Spring Boot提供了丰富灵活的跨域解决方案，从简单的注解到全局配置，再到与Spring Security的集成，可以满足各种复杂场景的需求。

**最佳实践建议**：
1. 开发环境可以使用宽松的配置，但生产环境一定要严格限制源域名
2. 注意凭证（Cookie）相关的配置，避免Session丢失问题
3. 合理设置maxAge，优化性能
4. 考虑整个架构，包括反向代理等组件的配置

跨域不是洪水猛兽，只要理解其原理并掌握正确的配置方法，就能轻松应对各种场景。希望本文能帮助你在实际开发中顺利解决跨域问题！

## 参考资料

1. https://blog.csdn.net/baidu_34422713/article/details/146609560
2. https://blog.51cto.com/u_16213400/12762391
3. https://www.yisu.com/zixun/813367.html
4. https://juejin.cn/post/7443784332165414947
5. https://www.yisu.com/jc/923461.html
6. https://blog.csdn.net/ahflex126r/article/details/151004546
7. https://www.jb51.net/program/285327jsh.htm
8. https://blog.csdn.net/weixin_39564368/article/details/113027045

* 本文主要观点基于以上参考资料，结合实际开发经验整理而成。转载请注明出处。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：**转载请注明原文出处及作者信息**