[toc]

## 0. 前言

你是否也跟我一样好奇，spring.datasource.url配置了多个数据源是如何实现高可用的？今天我们就来分析一下 Spring Boot 中数据源高可用实现的源码。我将从应用启动、连接获取、故障转移三个关键环节进行剖析。

## 1. 整体流程图概览

整个流程涉及多个层次，下图清晰地展示了核心组件及其交互关系：


![](https://files.mdnice.com/user/101007/d63c9b75-733e-421e-b643-8ddc3bb11290.png)


下面我们深入每个关键组件的源码细节。

---

## 2. Spring Boot 自动配置阶段

**入口：`DataSourceAutoConfiguration`**

Spring Boot 启动时，通过自动配置机制创建数据源。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {

    @Configuration(proxyBeanMethods = false)
    @Conditional(PooledDataSourceCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import({ DataSourceConfiguration.Hikari.class, // 默认优先使用Hikari
              DataSourceConfiguration.Tomcat.class,
              DataSourceConfiguration.Dbcp2.class,
              DataSourceConfiguration.Generic.class })
    protected static class PooledDataSourceConfiguration {
    }
}
```

*   **DataSourceProperties**： 这个类负责绑定 application.properties 中以 spring.datasource 为前缀的配置。
*   **@Import**：  Spring Boot 会按顺序尝试创建连接池。通常 Hikari 是默认首选。

**关键点**：Spring Boot 本身并不解析或处理URL中的多个IP地址。它只是将配置字符串原封不动地设置到 `DataSource` 实例中。**高可用的核心逻辑在数据库驱动和连接池层**。

---

## 3. 连接池初始化阶段（以 HikariCP 为例）

**入口：`HikariDataSource` 的构造和 `getConnection()` 方法**

当Spring Boot创建 `HikariDataSource` 实例后，会调用 `HikariDataSource.getConnection()` 来获取一个数据库连接。此时，连接池会创建一个真正的物理连接。

```java
public class HikariDataSource extends HikariConfig implements DataSource, Closeable {
    
    private final HikariPool fastPathPool;
    
    public HikariDataSource() {
        super();
        this.fastPathPool = new HikariPool(this); // 初始化连接池
    }
    
    @Override
    public Connection getConnection() throws SQLException {
        // 从连接池中获取一个连接
        return fastPathPool.getConnection();
    }
}
```

在 `HikariPool` 的构造函数中，会创建连接池并填充初始连接。创建单个物理连接的任务由 `PoolBase` 类的 `newConnection()` 方法完成。

```java
// 简化的 HikariPool 逻辑
public final class HikariPool implements HikariPoolMXBean, IBagStateListener {
    private final ConcurrentBag<PoolEntry> connectionBag;
    private final ConnectionFactory connectionFactory;
    
    public HikariPool(final HikariConfig config) {
        // ... 初始化工作
        this.connectionFactory = new DriverDataSource(
            config.getJdbcUrl(), 
            config.getDriverClassName(),
            config.getDataSourceProperties(), 
            config.getUsername(), 
            config.getPassword()
        );
        // ... 创建初始连接
    }
    
    private PoolEntry createPoolEntry() {
        try {
            // 最终调用 DriverDataSource 来创建连接
            final Connection connection = this.connectionFactory.createConnection();
            return new PoolEntry(connection, ...);
        } catch (Exception e) {
            // 处理连接异常
        }
    }
}
```

**关键点**：HikariCP 使用 `DriverDataSource`（它内部会调用 `java.sql.Driver.connect()`）来创建物理连接。**至此，控制权交给了JDBC驱动**。

---

## 4. JDBC 驱动故障转移阶段（以 MySQL Connector/J 为例）

这是最核心的部分。驱动需要解析URL并实现故障转移逻辑。

**入口：`com.mysql.cj.jdbc.NonRegisteringDriver#connect`**

所有JDBC驱动都必须实现 `java.sql.Driver` 接口，其 `connect` 方法是建立连接的入口。

```java
public class NonRegisteringDriver implements java.sql.Driver {
    @Override
    public java.sql.Connection connect(String url, Properties info) throws SQLException {
        // 1. 首先检查URL是否合法，是否以 jdbc:mysql: 开头
        if (!ConnectionUrl.acceptsUrl(url)) {
            return null;
        }
        
        // 2. 解析URL，创建ConnectionUrl实例
        ConnectionUrl connUrl = ConnectionUrl.getConnectionUrlInstance(url, info);
        // 对于多主机URL，如`replication:`或`loadbalance:`，会返回特定的子类
        
        // 3. 根据URL类型创建连接！
        return connUrl.connect(info);
    }
}
```

### 4.1 URL 解析与策略选择

`ConnectionUrl.getConnectionUrlInstance` 方法会根据URL的前缀决定创建哪种类型的连接策略：

*   `jdbc:mysql:replication://` -> `ReplicationConnectionUrl`
*   `jdbc:mysql:loadbalance://` -> `LoadbalanceConnectionUrl`
*   `jdbc:mysql:aws://` -> `AwsConnectionUrl`
*   普通的 `jdbc:mysql://` -> 如果包含多个主机，也会被识别为多主机配置。

**对于故障转移，我们重点关注 `ReplicationConnectionUrl`。**

### 4.2 连接建立与故障转移

`ReplicationConnectionUrl.connect` 会创建一个 `ReplicationConnectionProxy`，这个代理类管理着到多个主机的连接。

```java
// 简化的 ReplicationConnectionProxy 逻辑
public class ReplicationConnectionProxy extends MultiHostConnectionProxy {
    // 当前活动的主库连接
    private Connection currentMasterConnection;
    // 主库主机列表
    private List<HostInfo> masterHosts;
    
    @Override
    public Connection createConnectionForHost(HostInfo hostInfo) throws SQLException {
        // 这个方法会尝试连接一个特定的主机
        Properties props = hostInfo.exposeAsProperties();
        // 调用底层的驱动来创建单个连接
        return DriverManager.getConnection(hostInfo.getDatabaseUrl(), props);
    }
    
    // 选择主库连接的逻辑
    private void pickMasterConnection() throws SQLException {
        SQLException exception = null;
        
        // 遍历所有配置的主库主机 (A, B, C)
        for (HostInfo hostInfo : this.masterHosts) {
            try {
                // 尝试连接
                this.currentMasterConnection = createConnectionForHost(hostInfo);
                // 如果成功，则返回，过程结束
                return;
            } catch (SQLException e) {
                // 连接失败，记录异常并继续尝试下一个
                exception = e;
                // 重要：这里会记录日志，例如 "Could not connect to host A. Trying next host."
                continue; // 继续循环，尝试下一个主机B
            }
        }
        
        // 如果所有主机都尝试失败，抛出最后一个异常
        if (exception != null) {
            throw exception;
        }
    }
    
    // 当现有连接失效时，触发故障转移
    @Override
    public void doClose() {
        // 当前连接关闭或失效时
    }
    
    @Override
    public void ping() {
        try {
            // 对当前连接进行心跳检查
            this.currentMasterConnection.ping();
        } catch (SQLException e) {
            // 心跳失败，触发故障转移！
            try {
                pickMasterConnection(); // 重新选择主库连接
            } catch (SQLException ex) {
                // 故障转移也失败了
            }
        }
    }
}
```

### 4.3 超时机制的关键作用

源码中如何实现“快速失败”呢？这依赖于Socket超时设置。

在创建Socket连接时，驱动会使用 `connectTimeout` 参数：

```java
// 在 SocketConnection 类中
public class SocketConnection {
    public void connect(String hostName, int portNumber, Properties props) throws IOException {
        // ... 
        int connectTimeout = Integer.parseInt(props.getProperty("connectTimeout", "0"));
        Socket socket = new Socket();
        SocketAddress socketAddress = new InetSocketAddress(hostName, portNumber);
        
        // 设置连接超时，如果超过指定时间还未建立TCP连接，则抛出SocketTimeoutException
        socket.connect(socketAddress, connectTimeout);
        // ...
    }
}
```

*   **`connectTimeout`**: 决定了驱动尝试与数据库服务器建立TCP连接时等待的最长时间。如果IP A挂了，TCP握手会失败，在等待 `connectTimeout` 毫秒后，驱动会抛出异常，然后立即触发对主机B的连接尝试。
*   **`socketTimeout`**: 决定了数据库操作（如执行SQL）的等待时间。防止网络问题导致线程无限期挂起。

## 5. 总结

通过源码分析，我们可以清晰地看到高可用故障转移的实现链条：

1.  **Spring Boot**: 只是个“配置搬运工”，将 `spring.datasource.url` 传递给连接池。
2.  **连接池 (HikariCP)**: 是个“连接管理者”，负责调用 `Driver.connect(url, ...)` 来创建物理连接，并将连接池化以供复用。
3.  **数据库驱动 (MySQL Connector/J)**: 是“真正的英雄”，它：
    *   **解析URL**：识别出多个主机地址（A, B, C）。
    *   **实现故障转移算法**：在 `ReplicationConnectionProxy.pickMasterConnection()` 等方法中，**顺序遍历**主机列表，直到找到一个可连接的节点。
    *   **利用超时机制快速失败**：通过 `connectTimeout` 和 `socketTimeout` 避免长时间等待，从而实现快速切换。
    *   **提供心跳与重连**：通过 `ping` 等方法检测连接健康度，并在连接失效时再次触发故障转移流程。

因此，实现高可用的**关键**在于正确配置JDBC URL（使用支持故障转移的前缀）和设置合理的超时参数，从而激活数据库驱动内置的、经过充分测试的故障转移逻辑。

更多技术干货欢迎关注微信公众号“**科威舟的AI笔记**”~

![](https://files.mdnice.com/user/101007/5b1be244-b402-456b-bafb-63490ab66749.jpg)

【转载须知】：<font color=red>**转载请注明原文出处及作者信息**</font>