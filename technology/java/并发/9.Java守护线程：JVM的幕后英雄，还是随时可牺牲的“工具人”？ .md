[toc]

大家好，我是你们的后端技术老友**科威舟**，今天给大家分享一下守护进程

> 在Java多线程的世界里，有这样一种特殊的存在：它们默默工作在后台，为其他线程提供服务，却随时可能被JVM“抛弃”；它们辛勤工作，但却不能决定JVM的生死。这就是我们今天要聊的主角——守护线程（Daemon Thread）。本文将带你深入探究守护线程的奥秘，揭示它与用户线程的爱恨情仇，并分享在实际开发中如何正确使用这一技术。

## 1 守护线程的本质：JVM的“保姆”还是“备胎”？

想象一下，Java程序就像一个公司，用户线程是公司的正式员工，而守护线程则是公司的保洁阿姨。只要还有正式员工在加班，保洁阿姨就得陪着（尽管可能只是在刷手机）。但一旦所有正式员工都下班了，不管保洁阿姨的工作是否完成，她都会被强制“请出”办公室，灯也立刻被关闭。这就是守护线程最生动的比喻！

在Java中，线程分为两大阵营：**用户线程**和**守护线程**。它们的核心区别在于与JVM生命周期的关系。用户线程是“高富帅”，它们的存在直接决定了JVM的存亡。只要还有一个用户线程在运行，JVM就不会退出。而守护线程则是“备胎”，当所有用户线程结束时，即使守护线程还在执行任务，JVM也会毫不留情地终止它们，然后退出。

| 特性 | 用户线程 | 守护线程 |
|-----|---------|---------|
| 生命周期 | 独立，决定JVM存活 | 依赖用户线程，JVM退出时强制终止 |
| 默认类型 | 是 | 需显式设置 |
| 适用场景 | 核心业务逻辑 | 后台支持任务 |
| 优先级 | 通常较高 | 通常较低 |

Java虚拟机最典型的守护线程就是**垃圾回收器**。它在后台默默清理内存垃圾，不占用主营业务的时间，而且当主营业务结束时，它也跟着结束，不会拖慢系统的关闭速度。

那么，如何创建一个守护线程呢？其实非常简单，只需要在启动线程前调用一句设置方法：

```java
Thread daemonThread = new Thread(() -> {
    while (true) {
        System.out.println("我是守护线程，我在后台默默工作...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});

daemonThread.setDaemon(true);  // 关键一步，设置为守护线程
daemonThread.start();
```

但要注意：**设置守护线程必须在启动线程之前进行**，否则会抛出`IllegalThreadStateException`异常。这就好比你不能在员工入职后才突然改变他的劳动合同类型。

## 2 守护线程的创建与核心特性：如何与守护线程“打交道”

创建守护线程看似简单，但要想真正掌握它，就必须了解它的“脾气秉性”。让我们深入探讨守护线程的几个核心特性。

### 2.1 创建守护线程的正确姿势

创建一个守护线程不仅需要调用`setDaemon(true)`方法，还需要理解它的继承特性。**守护线程创建的线程默认也是守护线程**。这种“继承性”使得我们可以创建整个守护线程家族，一荣俱荣，一损俱损。

下面是一个更完整的创建示例：

```java
public class DaemonThreadDemo {
    public static void main(String[] args) {
        // 创建守护线程
        Thread daemonThread = new Thread(() -> {
            while (true) {
                try {
                    System.out.println("守护线程正在运行...");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // 必须在start()之前设置
        daemonThread.setDaemon(true); 
        daemonThread.start();
        
        // 主线程（用户线程）执行一些工作
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程结束，JVM即将退出");
    }
}
```

运行上面的代码，你会发现：当主线程休眠3秒结束后，尽管守护线程中有无限循环，但它还是会随着主线程的结束而被JVM终止。这就是守护线程“无私奉献”的本质。

### 2.2 守护线程的核心特性：卑微的“服务生”

守护线程有以下几个重要特性，理解这些特性是正确使用它们的关键：

1. **生命周期依赖性**：守护线程的生命完全依赖于用户线程。只要JVM中还有一个用户线程在运行，守护线程就能继续工作。一旦所有用户线程结束，守护线程立即被终止。

2. **自动终止**：与用户线程不同，守护线程的`finally`块不一定能保证执行。这意味着，如果你在守护线程中打开了资源（如文件、网络连接），当JVM退出时，这些资源可能无法正常关闭。

3. **低优先级**：虽然这不是强制要求，但守护线程通常被设置为较低优先级，以避免与用户线程竞争CPU资源。

4. **不适合关键任务**：由于守护线程可能在任何时候被终止，因此不适合执行关键任务，如数据保存、事务操作等。想象一下，如果数据库保存操作只执行到一半就被终止，会导致多么严重的数据不一致问题！

下面是一个展示守护线程资源清理问题的示例：

```java
public class DangerousDaemonDemo {
    public static void main(String[] args) {
        Thread dangerousDaemon = new Thread(() -> {
            try {
                FileWriter writer = new FileWriter("important_data.txt");
                // 模拟长时间写入操作
                for (int i = 0; i < 100000; i++) {
                    writer.write("重要数据：" + i + "\n");
                    Thread.sleep(10);
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                // 这里可能没有机会执行！
                System.out.println("尝试关闭资源...");
            }
        });
        
        dangerousDaemon.setDaemon(true);
        dangerousDaemon.start();
        
        // 主线程只等待1秒就结束
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("主线程结束，守护线程的写入操作可能只完成了一部分");
    }
}
```

在上面的例子中，由于主线程只等待1秒就结束，守护线程可能只写了一小部分数据到文件，文件句柄也没有正确关闭，导致数据丢失和资源泄漏。

## 3 实战应用场景：守护线程在真实世界中的角色

了解了守护线程的基本特性后，让我们看看它在实际开发中到底能扮演什么角色。下面介绍几个典型的使用场景，并附上代码示例。

### 3.1 日志记录系统：默默付出的记录员

在服务器应用中，日志记录是一个持续运行的后台任务。使用守护线程可以实现异步日志记录，避免阻塞主业务线程，同时确保主程序退出时日志线程自动终止。

下面是一个简单的日志记录守护线程实现：

```java
import java.io.FileWriter;
import java.io.IOException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class LoggingDaemon {
    private static final BlockingQueue<String> logQueue = new LinkedBlockingQueue<>();
    
    public static void main(String[] args) throws InterruptedException {
        // 创建日志守护线程
        Thread loggerThread = new Thread(() -> {
            try (FileWriter writer = new FileWriter("app.log", true)) {
                while (true) {
                    String log = logQueue.take(); // 阻塞等待日志
                    writer.write(log + "\n");
                    writer.flush();
                    System.out.println("记录日志: " + log);
                }
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        loggerThread.setDaemon(true);
        loggerThread.start();
        
        // 模拟主线程产生日志
        for (int i = 0; i < 5; i++) {
            logQueue.put("日志条目 " + i);
            Thread.sleep(500);
        }
        
        System.out.println("主线程退出，日志线程自动终止");
    }
}
```

在这个例子中，日志线程作为守护线程运行，负责将日志信息写入文件。主线程只需要将日志放入队列，而不需要等待实际的磁盘写入操作，大大提高了响应速度。当主线程结束后，日志线程自动终止，无需显式关闭。

### 3.2 资源监控与健康检查：系统的“体检医生”

另一个典型场景是系统资源监控。守护线程可以定期检查系统状态（CPU、内存、磁盘使用率等），并在超过阈值时发出警报。

```java
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;

public class ResourceMonitorDaemon {
    public static void main(String[] args) throws InterruptedException {
        Thread monitorThread = new Thread(() -> {
            OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
            while (true) {
                double load = osBean.getSystemLoadAverage();
                System.out.println("系统负载: " + load);
                
                if (load > 0.8) {
                    System.err.println("警告：系统负载过高！");
                }
                
                try {
                    Thread.sleep(5000); // 每5秒检查一次
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        monitorThread.setDaemon(true);
        monitorThread.start();
        
        // 模拟主业务运行
        System.out.println("主业务开始运行...");
        Thread.sleep(20000); // 运行20秒
        System.out.println("主业务运行结束");
    }
}
```

这种监控线程非常适合作为守护线程，因为它们提供的是辅助功能，不应该影响主程序的正常启动和关闭。

### 3.3 定时任务与缓存清理：后台的“清洁工”

守护线程也常用于执行定时任务，如定期清理临时文件、刷新缓存等。

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class CacheCleanerDaemon {
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1, r -> {
            Thread t = new Thread(r);
            t.setDaemon(true); // 将线程池中的线程设置为守护线程
            t.setName("CacheCleaner");
            return t;
        });
        
        // 每隔2秒清理一次缓存
        executor.scheduleAtFixedRate(() -> {
            System.out.println("清理过期缓存..." + System.currentTimeMillis());
        }, 0, 2, TimeUnit.SECONDS);
        
        // 主线程工作
        Thread.sleep(6000);
        System.out.println("主线程退出，缓存清理任务自动停止");
    }
}
```

通过自定义线程工厂，我们可以创建守护线程池，这样池中的所有线程都会是守护线程，随着主线程的结束而自动终止，无需手动关闭线程池。

### 3.4 分布式锁心跳续约：微服务架构中的“忠诚卫士”

在分布式系统中，守护线程可以用于维持分布式锁的心跳，确保在持有锁的实例正常运行时锁不会过期，而在实例关闭时锁能自动释放。

```java
import java.util.concurrent.*;

public class DistributedLock {
    private final ExecutorService renewExecutor = Executors.newSingleThreadExecutor(r -> {
        Thread t = new Thread(r);
        t.setDaemon(true);
        t.setName("LockRenewer");
        return t;
    });
    
    public void acquireLock(String lockKey) {
        // 获取锁的逻辑...
        startRenewTask(lockKey);
    }
    
    private void startRenewTask(String lockKey) {
        renewExecutor.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    // 每10秒续约一次
                    redisTemplate.expire(lockKey, 30, TimeUnit.SECONDS);
                    TimeUnit.SECONDS.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
    }
}
```

在这个例子中，守护线程负责定期续约分布式锁。如果应用程序意外终止，守护线程会自动停止续约，分布式锁会因过期而自动释放，避免了死锁情况的发生。

## 4 生产环境注意事项：守护线程的“陷阱”与最佳实践

虽然守护线程在很多场景下非常有用，但如果不了解其特性，很容易踩坑。下面介绍几个在生产环境中使用守护线程时需要注意的问题。

### 4.1 资源清理：不要相信守护线程的finally块

由于守护线程可能被JVM强制终止，`finally`块中的代码不一定能执行，这可能导致资源泄漏。

**错误示例：**
```java
// 危险：守护线程中的资源可能无法正确关闭
daemonExecutor.submit(() -> {
    FileInputStream fis = new FileInputStream("data.log");
    // 处理文件...
    // 如果此时JVM退出，文件流将无法关闭
});
```

**正确做法：**
```java
// 安全：使用try-with-resources确保资源释放
daemonExecutor.submit(() -> {
    try (FileInputStream fis = new FileInputStream("data.log")) {
        // 处理文件...
    } catch (IOException e) {
        log.error("文件处理异常", e);
    }
});
```

使用try-with-resources语法可以确保即使守护线程被终止，资源也能正确关闭。

### 4.2 事务上下文管理：守护线程中的事务问题

在Spring框架中，事务上下文是与线程绑定的。守护线程不能自动继承用户线程的事务上下文，这可能导致意外行为。

**问题代码：**
```java
@Transactional
public void processOrder(Order order) {
    daemonExecutor.submit(() -> {
        // 此处无法继承事务上下文！
        inventoryService.deductStock(order); // 可能抛出异常导致数据不一致
    });
}
```

**解决方案：**
```java
@Autowired
private PlatformTransactionManager transactionManager;

public void processOrder(Order order) {
    daemonExecutor.submit(() -> {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.execute(status -> {
            inventoryService.deductStock(order);
            return null;
        });
    });
}
```

### 4.3 优雅停机策略：给守护线程一个“告别”的机会

虽然JVM退出时会强制终止守护线程，但在生产环境中，我们仍然应该实现优雅停机逻辑，尽量让守护线程完成当前工作。

```java
@Component
public class GracefulShutdown {
    @Autowired
    private ExecutorService daemonExecutor;
    
    @PreDestroy
    public void gracefulShutdown() {
        System.out.println("开始关闭守护线程池...");
        daemonExecutor.shutdown();
        try {
            if (!daemonExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                List<Runnable> droppedTasks = daemonExecutor.shutdownNow();
                System.out.println("强制关闭，丢弃" + droppedTasks.size() + "个任务");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## 5 总结：正确使用守护线程，让Java程序更健壮

守护线程是Java多线程编程中一个非常重要但又容易被忽视的概念。它们就像是JVM世界的“幕后工作者”，默默为用户线程提供服务，却不求回报。通过本文的学习，我们应该掌握：

1. **守护线程的本质**：生命周期依赖于用户线程，当所有用户线程结束时自动终止。
2. **适用场景**：适合用于日志记录、资源监控、定时任务等非关键性后台任务。
3. **使用禁忌**：不适合执行关键任务，如数据持久化、事务操作等。
4. **最佳实践**：注意资源清理、事务上下文管理和优雅停机策略。

回到我们开篇的比喻，守护线程就像是公司的保洁阿姨，虽然地位看似"卑微"，但却是整个系统高效运转的重要保障。我们需要尊重它们的"特性"，分配合适的"工作"，才能让它们发挥最大价值。

希望通过本文的介绍，你能对Java守护线程有更深入的理解，并在实际项目中灵活运用这一技术，构建出更加健壮、高效的Java应用程序！

--- 
**参考资料：**
1. https://blog.csdn.net/weixin_30648587/article/details/101567513
2. https://blog.csdn.net/weixin_39505595/article/details/81077742
3. https://blog.csdn.net/Wanankl/article/details/149748743
4. https://blog.51cto.com/u_17035323/14043247
5. https://m.php.cn/faq/1380166.html
6. https://juejin.cn/post/7294150742113550362
7. https://blog.csdn.net/Flying_Fish_roe/article/details/143033486
8. https://blog.51cto.com/u_16175479/6820014
9. https://juejin.cn/post/7474019962719617050

*关注我的公众号，获取更多Java技术干货！如果你有有趣的守护线程使用经验，欢迎在评论区分享～*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/40fb2530-2565-4f14-a1df-8f581b1b1d70.png)

【转载须知】：**转载请注明原文出处及作者信息**