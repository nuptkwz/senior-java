[toc]

大家好，我是你们的技术老友**科威舟**，今天给大家分享一下Java中的有界队列VS无界队列。

> 技术圈里有个经典问题：为什么公交车要有载客量限制？这正如同我们今天要讨论的有界队列和无界队列的区别。

在并发编程世界中，阻塞队列（BlockingQueue）是一个不可或缺的组件，它是多线程间的通信桥梁，也是生产者-消费者模式的核心实现。而其中最重要的分类就是——**有界队列**和**无界队列**。

## 一、从现实生活理解有界与无界

想象一下你所在城市的公交车：

- **有界队列**：就像标准载客量的公交车，一旦座位和站位满员，新乘客必须等待有人下车才能上车。这就是**有界阻塞队列**的现实映射。

- **无界队列**：则像高峰期的地铁，理论上可以不断挤上更多人，虽然实际还是有物理极限，但在达到系统极限前，几乎可以一直容纳新乘客。这就是**无界队列**的特点。

在Java世界中，有界队列以ArrayBlockingQueue为代表，创建时必须指定容量；而无界队列以LinkedBlockingQueue（默认容量为Integer.MAX_VALUE）为代表。

## 二、七种阻塞队列的“兵器谱”

Java提供了丰富的阻塞队列实现，每种都有其独特特性：

1. **ArrayBlockingQueue**：基于数组的有界队列，内部使用单个ReentrantLock控制并发
2. **LinkedBlockingQueue**：基于链表的可选有界队列，使用独立的putLock和takeLock，吞吐量通常更高
3. **PriorityBlockingQueue**：支持优先级排序的无界队列
4. **DelayQueue**：基于优先级队列的无界队列，只有延迟期满时才能获取元素
5. **SynchronousQueue**：不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作
6. **LinkedTransferQueue**：基于链表的无界队列，支持transfer和tryTransfer方法
7. **LinkedBlockingDeque**：基于链表的双向有界阻塞队列

## 三、有界队列的“安全阀门”作用

有界队列最大的优势在于它提供了**背压（backpressure）** 机制。当生产者速度超过消费者时，队列会满，此时生产者线程会被阻塞，从而自然形成生产速度的调节。

```java
// 有界队列示例 - 安全的"流量控制"
BlockingQueue<Integer> boundedQueue = new LinkedBlockingQueue<>(10); // 容量为10

// 生产者线程
new Thread(() -> {
    try {
        for (int i = 0; i < 100; i++) {
            // 当队列满时，put方法会阻塞，防止无限制增长
            boundedQueue.put(i); 
            System.out.println("生产了: " + i);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```

有界队列就像有个明智的项目经理，当团队工作量饱和时，他会说：“慢点来，我们先完成手头任务”，从而避免系统过载。

## 四、无界队列的“风险与收益”

无界队列在创建时不需要指定容量（或默认容量极大，如Integer.MAX_VALUE），理论上可以无限增长。

```java
// 无界队列示例 - 高风险高吞吐
BlockingQueue<Integer> unboundedQueue = new LinkedBlockingQueue<>(); // 默认容量极大

// 生产者可以持续快速生产，不会阻塞
new Thread(() -> {
    try {
        int i = 0;
        while (true) {
            unboundedQueue.put(i++); // 几乎不会阻塞
            System.out.println("快速生产: " + i);
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```

无界队列就像个过于乐观的创业者，总认为资源是无限的，可以不断承接新任务。但风险在于，如果消费速度跟不上生产速度，最终可能导致**内存耗尽**，引发OutOfMemoryError。

## 五、核心方法的行为差异

有界和无界队列在方法行为上也有明显差异：

### 插入操作对比

| 方法 | 有界队列行为 | 无界队列行为 |
|------|-------------|-------------|
| add(e) | 队列满时抛出异常 | 几乎总是成功 |
| put(e) | 队列满时阻塞等待 | 几乎从不阻塞 |
| offer(e) | 队列满时返回false | 几乎总是返回true |
| offer(e, timeout, unit) | 队列满时超时等待 | 几乎立即成功 |

### 获取操作对比

| 方法 | 有界队列行为 | 无界队列行为 |
|------|-------------|-------------|
| take() | 队列空时阻塞 | 队列空时阻塞 |
| poll() | 队列空时返回null | 队列空时返回null |
| poll(timeout, unit) | 队列空时超时等待 | 队列空时超时等待 |

从表中可以看出，**主要差异体现在插入操作上**，因为无界队列理论上永远不会满。

## 六、选择策略：何时用有界，何时用无界

### 适合有界队列的场景：

1. **资源敏感环境**：内存有限或需要稳定内存占用的系统
2. **需要背压机制**：希望生产者速度能与消费者速度自动匹配
3. **实时系统**：需要可预测的内存行为和响应时间
4. **防止雪崩效应**：避免因消费者暂时故障导致内存爆满

### 适合无界队列的场景：

1. **高吞吐场景**：生产者-消费者速度基本匹配，且不希望因队列满而阻塞生产者
2. **临时任务队列**：如线程池的任务队列，任务量波动大但不会长期堆积
3. **内存充足环境**：且确信消费者不会长时间故障
4. **数据流处理**：需要尽可能高的吞吐量，且有能力处理背压

## 七、实战案例：线程池中的队列选择

线程池是阻塞队列最典型的应用场景，不同的队列选择会极大影响线程池行为：

```java
// 案例1：有界队列 + 自定义拒绝策略
ThreadPoolExecutor boundedExecutor = new ThreadPoolExecutor(
    4,  // 核心线程数
    8,  // 最大线程数  
    1, TimeUnit.MINUTES,
    new ArrayBlockingQueue<>(100),  // 有界队列
    new ThreadPoolExecutor.CallerRunsPolicy()  // 队列满时由调用线程执行
);

// 案例2：无界队列 - 注意可能的内存风险
ThreadPoolExecutor unboundedExecutor = new ThreadPoolExecutor(
    4,  // 核心线程数
    8,  // 最大线程数
    1, TimeUnit.MINUTES, 
    new LinkedBlockingQueue<>()  // 无界队列 - 风险！
);
```

在有界队列的配置中，当队列满且线程数达到最大值时，会触发拒绝策略，防止资源耗尽。而无界队列可能允许任务无限堆积，最终导致内存溢出。

## 八、总结：有界与无界的哲学思考

有界队列代表了一种**保守而稳健**的设计哲学：承认资源有限，需要边界和约束。它像一位谨慎的规划师，确保系统在可控范围内运行。

无界队列则体现了一种**乐观而冒险**的精神：相信资源足够，追求极限性能。它像一位激进的开拓者，试图突破一切限制。

在实际开发中，**没有绝对的优劣**，只有适合与不适合。明智的开发者会根据具体场景灵活选择，有时甚至会采用混合策略，比如使用“软边界”队列，或者动态调整队列容量。

## 参考文章

1. https://docs.pingcode.com/baike/293219
2. https://blog.csdn.net/niugang0920/article/details/120463461
3. https://blog.51cto.com/u_16099178/6775892
4. https://blog.csdn.net/qq_34358193/article/details/140890603
5. https://www.51cto.com/article/804817.html
6. https://www.cnblogs.com/BlogNetSpace/p/17119937.html
7. https://www.cnblogs.com/signheart/p/6606475.html

---

*本文仅供技术学习参考，如有错误欢迎指正。*

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/40fb2530-2565-4f14-a1df-8f581b1b1d70.png)

【转载须知】：**转载请注明原文出处及作者信息**

