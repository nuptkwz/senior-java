[toc]

大家好，我是你们的船长：**科威舟**，今天给大家分享一下分布式锁。

> 分布式锁不仅是技术，更是艺术。

作为一名软件开发者，在分布式系统中摸爬滚打多年，我终于领悟到一个道理：在分布式系统里，锁就像是生活中的交通信号灯——没有它，秩序荡然无存；有它不当，则可能造成更严重的拥堵。

今天，就让我们一起深入探讨分布式锁的奇妙世界。

## 为什么需要分布式锁？

想象一下双十一的秒杀场景：数万用户同时点击"立即购买"，而库存只有100件。如果没有适当的锁机制，结果将是灾难性的——**超卖**（库存减到负数）或**重复下单**（同一用户抢到多件）。

在单机环境中，我们可以使用synchronized或ReentrantLock来控制并发。但在分布式系统中，应用部署在多台服务器上，单机锁**无法跨进程协调**，这时就需要分布式锁登场了。

分布式锁的核心使命是：在分布式环境下，确保对共享资源的访问具有**排他性**，即同一时刻只有一个客户端能够对资源进行操作。

## 分布式锁的四大核心要求

一个合格的分布式锁必须满足以下条件：

1.  **互斥性**：这是锁的基本功，保证在任何时刻，只有一个客户端能持有锁。
2.  **避免死锁**：即使持有锁的客户端崩溃，锁也能被正确释放，不会导致系统永久阻塞。
3.  **容错性**：只要大部分节点正常，锁服务就应保持可用。
4.  **对称性**：加锁和解锁必须是同一个客户端，不能出现"A加的锁被B释放"的情况。

## Redis分布式锁的实现之道

在多种分布式锁实现方案（数据库、ZooKeeper、Redis等）中，Redis因其高性能和相对简单的实现，成为**最受欢迎的选择**。

### 最基本实现：SETNX命令

早期，开发者使用Redis的SETNX（SET if Not eXists）命令实现分布式锁：

```
// 加锁
SETNX lock_key 1
// 设置过期时间
EXPIRE lock_key 30
// 释放锁
DEL lock_key
```

但这种方式有个致命缺陷：SETNX和EXPIRE是**两个独立操作**，不具备原子性。如果客户端在SETNX后崩溃，来不及设置过期时间，就会导致**死锁**。

### 正确姿势：原子操作

Redis 2.6.12后支持SET命令的NX和EX参数，**一次性完成设置值和过期时间**：

```
SET lock_name my_random_value NX PX 30000
```

- **NX**：仅当key不存在时才设置，保证互斥性
- **PX 30000**：设置30秒过期时间，避免死锁
- **my_random_value**：唯一标识，确保只能由锁持有者释放

### 释放锁的陷阱与解决方案

释放锁并非简单的DEL操作，考虑以下场景：

1.  客户端A获取锁，执行时间过长（如GC暂停），锁过期自动释放
2.  客户端B获取锁
3.  客户端A从暂停中恢复，执行DEL操作
4.  结果：客户端A**误删了客户端B的锁**

解决方案是使用Lua脚本保证**判断和删除的原子性**：

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

先验证锁的value是否匹配（证明是自己的锁），再删除。

## 锁超时了怎么办？

锁超时是分布式锁中最棘手的问题之一，它就像是给你的锁上了一道"自动销毁"定时器。

### 为什么需要超时时间？

设置超时时间主要是为了**避免死锁**。当客户端持有锁期间发生崩溃或网络分区，如果没有超时机制，其他客户端将永远无法获得锁。

### 超时带来的新问题

然而，超时机制引入了新的挑战——**锁提前释放**：

1.  客户端A获取锁，设置30秒超时
2.  客户端A因GC暂停或网络延迟，处理时间超过30秒
3.  锁超时释放，客户端B获取锁
4.  现在，客户端A和B**同时访问共享资源**，互斥性被破坏

### 解决方案

#### 1. 合理设置超时时间

根据业务逻辑的**最长时间**合理设置超时时间，并留出充足余量。例如，正常操作需要10秒，可设置30秒超时。

#### 2. 锁续期（Lock Renewal）

启动一个**守护线程**，在锁即将过期时自动延长锁的持有时间。Redisson等成熟的分布式锁库已内置此功能，它定期检查客户端是否仍在运行，并相应延长锁的过期时间。

#### 3. 红锁（RedLock）算法

Redis作者Antirez提出了RedLock算法，要求在**多个独立的Redis实例**上获取锁，且大多数实例获取成功才算真正获得锁。这降低了因单个Redis实例故障导致锁失效的概率。

## 超越Redis：其他分布式锁实现

### 基于ZooKeeper的实现

ZooKeeper通过**临时顺序节点**实现分布式锁：

1.  所有客户端在锁节点下创建临时顺序子节点
2.  判断自己是否为最小节点，是则获得锁
3.  否则，监听比自己小1的节点，等待通知

ZooKeeper锁的优势在于**可靠性高**，但性能不如Redis。

### 基于数据库的实现

通过数据库的**唯一索引**或**排他锁**实现分布式锁，实现简单但性能较差，不适合高并发场景。

## 实践建议：选择合适的分布式锁

1.  **性能优先**：选择Redis实现，适合高并发、可容忍极端情况下锁失效的场景
2.  **可靠性优先**：选择ZooKeeper实现，适合对一致性要求高的场景
3.  **简单场景**：可考虑数据库实现，避免引入新组件
4.  **锁粒度**：尽量**细化锁的粒度**，如对商品锁使用商品ID而非全局锁
5.  **锁范围**：**减少持锁时间**，只锁关键代码段

## 结语

分布式锁是分布式系统的**守护者**，它既带来了秩序，也引入了复杂度。在实际应用中，没有完美的解决方案，只有最适合业务场景的选择。

即使是最完善的分布式锁方案，也无法保证100%的安全性。在设计系统时，需要根据业务特点权衡**性能**与**一致性**的需求。

希望本文能帮助你在分布式系统的世界里更加游刃有余。毕竟，掌握好分布式锁，就是在分布式世界里掌握了一把**秩序的钥匙**。

---
更多技术干货欢迎关注微信公众号**科威舟的AI笔记**~

![](https://files.mdnice.com/user/101007/40fb2530-2565-4f14-a1df-8f581b1b1d70.png)

【转载须知】：**转载请注明原文出处及作者信息**

